###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:16:23 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\MMC_MCI_Atmel.c                      #
#    Command line =  C:\DUII\TargetHW\FS\MMC_MCI_Atmel.c -D DEBUG=1 -D        #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\MMC_MCI_Atmel.lst          #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\MMC_MCI_Atmel.o             #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\MMC_MCI_Atmel.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2007     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FS_MMC_CM_Atmel.c
     19          Purpose     : FS driver for ATMEL MCI SD/MMC card mode interface.
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          /*********************************************************************
     24          *
     25          *       #include Section
     26          *
     27          **********************************************************************
     28          */
     29          
     30          #include "FS_ConfDefaults.h"        /* FS Configuration */
     31          
     32          #include "FS_Int.h"
     33          #include "FS_CLib.h"
     34          #include "MMC_MCI_HW.h"
     35          /*********************************************************************
     36          *
     37          *       #define constants
     38          *
     39          **********************************************************************
     40          */
     41          #ifndef NUM_UNITS
     42            #define NUM_UNITS         2
     43          #endif
     44          
     45          // Transfer is pending.
     46          #define MCI_STATUS_PENDING      1
     47          // Transfer has been aborted because an error occurred.
     48          #define MCI_STATUS_ERROR        2
     49          // Card did not answer command.
     50          #define MCI_STATUS_NORESPONSE   3
     51          
     52          // MCI driver is currently in use.
     53          #define MCI_ERROR_LOCK    1
     54          
     55          
     56          // Start new data transfer
     57          #define MCI_NEW_TRANSFER        0
     58          // Continue data transfer
     59          #define MCI_CONTINUE_TRANSFER   1
     60          
     61          // MCI SD Bus Width 1-bit
     62          #define MCI_SDCBUS_1BIT (0 << 7)
     63          // MCI SD Bus Width 4-bit
     64          #define MCI_SDCBUS_4BIT (1 << 7)
     65          
     66          
     67          // SD card block size binary shift value
     68          #define SECTOR_SIZE_SHIFT       9
     69          // SD card block size in bytes.
     70          #define SECTOR_SIZE           (1 << SECTOR_SIZE_SHIFT)
     71          
     72          // -------- MCI_CR : (MCI Offset: 0x0) MCI Control Register --------
     73          #define AT91C_MCI_MCIEN                       (0x1      <<  0) // (MCI) Multimedia Interface Enable
     74          #define AT91C_MCI_MCIDIS                      (0x1      <<  1) // (MCI) Multimedia Interface Disable
     75          #define AT91C_MCI_PWSEN                       (0x1      <<  2) // (MCI) Power Save Mode Enable
     76          #define AT91C_MCI_PWSDIS                      (0x1      <<  3) // (MCI) Power Save Mode Disable
     77          #define AT91C_MCI_SWRST                       (0x1      <<  7) // (MCI) MCI Software reset
     78          // -------- MCI_MR : (MCI Offset: 0x4) MCI Mode Register --------
     79          #define AT91C_MCI_CLKDIV                      (0xFFUL   <<  0) // (MCI) Clock Divider
     80          #define AT91C_MCI_PWSDIV                      (0x07     <<  8) // (MCI) Power Saving Divider
     81          #define AT91C_MCI_RDPROOF                     (0x01     << 11) // (MCI) Read Proof Enable
     82          #define AT91C_MCI_WRPROOF                     (0x01     << 12) // (MCI) Write Proof Enable
     83          #define AT91C_MCI_PDCFBYTE                    (0x01     << 13) // (MCI) PDC Force Byte Transfer
     84          #define AT91C_MCI_PDCPADV                     (0x01     << 14) // (MCI) PDC Padding Value
     85          #define AT91C_MCI_PDCMODE                     (0x01     << 15) // (MCI) PDC Oriented Mode
     86          #define AT91C_MCI_BLKLEN                      (0xFFFFUL << 16) // (MCI) Data Block Length
     87          // MCI Data Timeout Register
     88          #define MCI_DTOR_DTOCYC                       (0x0F    <<  0) // (MCI) Data Timeout Cycle Number
     89          #define MCI_DTOR_DTOMUL                       (0x07    <<  4) // (MCI) Data Timeout Multiplier
     90          #define MCI_DTOR_DTOMUL_1                     (0x00    <<  4) // (MCI) DTOCYC x 1
     91          #define MCI_DTOR_DTOMUL_16                    (0x01    <<  4) // (MCI) DTOCYC x 16
     92          #define MCI_DTOR_DTOMUL_128                   (0x02    <<  4) // (MCI) DTOCYC x 128
     93          #define MCI_DTOR_DTOMUL_256                   (0x03    <<  4) // (MCI) DTOCYC x 256
     94          #define MCI_DTOR_DTOMUL_1024                  (0x04    <<  4) // (MCI) DTOCYC x 1024
     95          #define MCI_DTOR_DTOMUL_4096                  (0x05    <<  4) // (MCI) DTOCYC x 4096
     96          #define MCI_DTOR_DTOMUL_65536                 (0x06    <<  4) // (MCI) DTOCYC x 65536
     97          #define MCI_DTOR_DTOMUL_1048576               (0x07    <<  4) // (MCI) DTOCYC x 1048576
     98          // MCI SD Card Register --------
     99          #define MCI_SDCR_SCDSEL                       (0x3     <<  0) // (MCI) SD Card Selector
    100          #define MCI_SDCR_SCDBUS                       (0x1UL   <<  7) // (MCI) SDCard/SDIO Bus Width
    101          // MCI Command Register bit definitions
    102          #define MCI_CMDR_CMDNB                        (0x3F    <<  0) // (MCI) Command Number
    103          #define MCI_CMDR_RSPTYP                       (0x03    <<  6) // (MCI) Response Type
    104          #define MCI_CMDR_RSPTYP_NO                    (0x00    <<  6) // (MCI) No response
    105          #define MCI_CMDR_RSPTYP_48                    (0x01    <<  6) // (MCI) 48-bit response
    106          #define MCI_CMDR_RSPTYP_136                   (0x02    <<  6) // (MCI) 136-bit response
    107          #define MCI_CMDR_SPCMD                        (0x07    <<  8) // (MCI) Special CMD
    108          #define MCI_CMDR_SPCMD_NONE                   (0x00    <<  8) // (MCI) Not a special CMD
    109          #define MCI_CMDR_SPCMD_INIT                   (0x01    <<  8) // (MCI) Initialization CMD
    110          #define MCI_CMDR_SPCMD_SYNC                   (0x02    <<  8) // (MCI) Synchronized CMD
    111          #define MCI_CMDR_SPCMD_IT_CMD                 (0x04    <<  8) // (MCI) Interrupt command
    112          #define MCI_CMDR_SPCMD_IT_REP                 (0x05    <<  8) // (MCI) Interrupt response
    113          #define MCI_CMDR_OPDCMD                       (0x01    << 11) // (MCI) Open Drain Command
    114          #define MCI_CMDR_MAXLAT                       (0x01    << 12) // (MCI) Maximum Latency for Command to respond
    115          #define MCI_CMDR_TRCMD                        (0x03    << 16) // (MCI) Transfer CMD
    116          #define MCI_CMDR_TRCMD_NO                     (0x00    << 16) // (MCI) No transfer
    117          #define MCI_CMDR_TRCMD_START                  (0x01    << 16) // (MCI) Start transfer
    118          #define MCI_CMDR_TRCMD_STOP                   (0x02    << 16) // (MCI) Stop transfer
    119          #define MCI_CMDR_TRDIR                        (0x01    << 18) // (MCI) Transfer Direction
    120          #define MCI_CMDR_TRTYP                        (0x07    << 19) // (MCI) Transfer Type
    121          #define MCI_CMDR_TRTYP_BLOCK                  (0x00    << 19) // (MCI) MMC/SDCard Single Block Transfer type
    122          #define MCI_CMDR_TRTYP_MULTIPLE               (0x01    << 19) // (MCI) MMC/SDCard Multiple Block transfer type
    123          #define MCI_CMDR_TRTYP_STREAM                 (0x02    << 19) // (MCI) MMC Stream transfer type
    124          #define MCI_CMDR_TRTYP_SDIO_BYTE              (0x04    << 19) // (MCI) SDIO Byte transfer type
    125          #define MCI_CMDR_TRTYP_SDIO_BLOCK             (0x05    << 19) // (MCI) SDIO Block transfer type
    126          #define MCI_CMDR_IOSPCMD                      (0x03    << 24) // (MCI) SDIO Special Command
    127          #define MCI_CMDR_IOSPCMD_NONE                 (0x00    << 24) // (MCI) NOT a special command
    128          #define MCI_CMDR_IOSPCMD_SUSPEND              (0x01    << 24) // (MCI) SDIO Suspend Command
    129          #define MCI_CMDR_IOSPCMD_RESUME               (0x02    << 24) // (MCI) SDIO Resume Command
    130          
    131          // MCI Status Register bit definitions
    132          #define MCI_STATUS_CMDRDY                     (0x01    <<  0) // (MCI) Command Ready flag
    133          #define MCI_STATUS_BLKE                       (0x01    <<  3) // (MCI) Data Block Transfer Ended flag
    134          #define MCI_STATUS_DTIP                       (0x01    <<  4) // (MCI) Data Transfer in Progress flag
    135          #define MCI_STATUS_NOTBUSY                    (0x01    <<  5) // (MCI) Data Line Not Busy flag
    136          #define MCI_STATUS_ENDRX                      (0x01    <<  6) // (MCI) End of RX Buffer flag
    137          #define MCI_STATUS_ENDTX                      (0x01    <<  7) // (MCI) End of TX Buffer flag
    138          #define MCI_STATUS_RXBUFF                     (0x01    << 14) // (MCI) RX Buffer Full flag
    139          #define MCI_STATUS_RINDE                      (0x01    << 16) // (MCI) Response Index Error flag
    140          #define MCI_STATUS_RDIRE                      (0x01    << 17) // (MCI) Response Direction Error flag
    141          #define MCI_STATUS_RCRCE                      (0x01    << 18) // (MCI) Response CRC Error flag
    142          #define MCI_STATUS_RENDE                      (0x01UL  << 19) // (MCI) Response End Bit Error flag
    143          #define MCI_STATUS_RTOE                       (0x01UL  << 20) // (MCI) Response Time-out Error flag
    144          #define MCI_STATUS_DCRCE                      (0x01UL  << 21) // (MCI) data CRC Error flag
    145          #define MCI_STATUS_DTOE                       (0x01UL  << 22) // (MCI) Data timeout Error flag
    146          #define MCI_STATUS_OVRE                       (0x01UL  << 30) // (MCI) Overrun flag
    147          #define MCI_STATUS_UNRE                       (0x01UL  << 31) // (MCI) Underrun flag
    148          
    149          #define AT91C_PDC_RXTEN       (0x1 <<  0) // (PDC) Receiver Transfer Enable
    150          #define AT91C_PDC_RXTDIS      (0x1 <<  1) // (PDC) Receiver Transfer Disable
    151          #define AT91C_PDC_TXTEN       (0x1 <<  8) // (PDC) Transmitter Transfer Enable
    152          #define AT91C_PDC_TXTDIS      (0x1 <<  9) // (PDC) Transmitter Transfer Disable
    153          
    154          
    155          /*********************************************************************
    156          *
    157          *       Defines, non-configurable
    158          *
    159          **********************************************************************
    160          */
    161          // SD card operation states
    162          #define SD_STATE_STBY     0
    163          #define SD_STATE_DATA     1
    164          #define SD_STATE_RCV      2
    165          // Card type
    166          #define UNKNOWN_CARD   0
    167          #define CARD_SD        1
    168          #define CARD_SDHC      2
    169          #define CARD_MMC       3
    170          
    171          // Delay between sending MMC commands
    172          #define MMC_DELAY 0x4ff
    173          
    174          #define SD_SECTOR_NO(pInst, SectorNo) (((pInst)->CardType == CARD_SDHC) ? (SectorNo):((SectorNo) << SECTOR_SIZE_SHIFT))
    175          
    176          // Status register constants
    177          #define STATUS_READY_FOR_DATA   (1 << 8)
    178          #define STATUS_IDLE             (0 << 9)
    179          #define STATUS_READY            (1 << 9)
    180          #define STATUS_IDENT            (2 << 9)
    181          #define STATUS_STBY             (3 << 9)
    182          #define STATUS_TRAN             (4 << 9)
    183          #define STATUS_DATA             (5 << 9)
    184          #define STATUS_RCV              (6 << 9)
    185          #define STATUS_PRG              (7 << 9)
    186          #define STATUS_DIS              (8 << 9)
    187          #define STATUS_STATE            (0xF << 9)
    188          
    189          // Voltage that we can handle (OCR)
    190          #define VDD_27_28                (1UL << 15)
    191          #define VDD_28_29                (1UL << 16)
    192          #define VDD_29_30                (1UL << 17)
    193          #define VDD_30_31                (1UL << 18)
    194          #define VDD_31_32                (1UL << 19)
    195          #define VDD_32_33                (1UL << 20)
    196          // Bit 31 of OCR is set, device is
    197          #define CARD_POWER_UP_BUSY       (1UL << 31)
    198          
    199          #define MMC_HOST_VOLTAGE_RANGE     (VDD_27_28 +\
    200                                              VDD_28_29 +\
    201                                              VDD_29_30 +\
    202                                              VDD_30_31 +\
    203                                              VDD_31_32 +\
    204                                              VDD_32_33)
    205          
    206          #define SD_CCS              (1 << 30)
    207          
    208          /// There was an error with the MCI driver.
    209          #define SD_ERROR_MCI             1
    210          /// The SD card did not answer the command.
    211          #define SD_ERROR_NORESPONSE      2
    212          /// The SD card did not answer the command.
    213          #define SD_ERROR_NOT_INITIALIZED 3
    214          
    215          // CSD register access macros.
    216          #define SD_CSD(pInst, Bitfield, Bits)   ((((pInst)->csd)[3-(Bitfield) / 32] >> ((Bitfield) & 0x1f)) & ((1 << (Bits)) - 1))
    217          #define SD_CSD_STRUCTURE(pInst)          SD_CSD(pInst, 126, 2) ///< CSD structure 00b  Version 1.0 01b version 2.0 High Cap
    218          #define SD_CSD_TAAC(pInst)               SD_CSD(pInst, 112, 8) ///< Data read-access-time-1
    219          #define SD_CSD_NSAC(pInst)               SD_CSD(pInst, 104, 8) ///< Data read access-time-2 in CLK cycles
    220          #define SD_CSD_TRAN_SPEED(pInst)         SD_CSD(pInst, 96,  8) ///< Max. data transfer rate
    221          #define SD_CSD_READ_BL_LEN(pInst)        SD_CSD(pInst, 80,  4) ///< Max. read data block length
    222          #define SD_CSD_READ_BL_PARTIAL(pInst)    SD_CSD(pInst, 79,  1) ///< Partial blocks for read allowed
    223          #define SD_CSD_WRITE_BLK_MISALIGN(pInst) SD_CSD(pInst, 78,  1) ///< Write block misalignment
    224          #define SD_CSD_READ_BLK_MISALIGN(pInst)  SD_CSD(pInst, 77,  1) ///< Read block misalignment
    225          #define SD_CSD_DSR_IMP(pInst)            SD_CSD(pInst, 76,  1) ///< DSP implemented
    226          #define SD_CSD_C_SIZE(pInst)             ((SD_CSD(pInst, 64,  10) << 2) + SD_CSD(pInst, 62,  2)) ///< Device size
    227          #define SD_CSD_C_SIZE_HC(pInst)          ((SD_CSD(pInst, 64,  6) << 16) + SD_CSD(pInst, 48,  16)) ///< Device size v2.0 High Capacity
    228          #define SD_CSD_VDD_R_CURR_MIN(pInst)     SD_CSD(pInst, 59,  3) ///< Max. read current @VDD min
    229          #define SD_CSD_VDD_R_CURR_MAX(pInst)     SD_CSD(pInst, 56,  3) ///< Max. read current @VDD max
    230          #define SD_CSD_VDD_W_CURR_MIN(pInst)     SD_CSD(pInst, 53,  3) ///< Max. write current @VDD min
    231          #define SD_CSD_VDD_W_CURR_MAX(pInst)     SD_CSD(pInst, 50,  3) ///< Max. write current @VDD max
    232          #define SD_CSD_C_SIZE_MULT(pInst)        SD_CSD(pInst, 47,  3) ///< Device size multiplier
    233          #define SD_CSD_ERASE_BLK_EN(pInst)       SD_CSD(pInst, 46,  1) ///< Erase single block enable
    234          #define SD_CSD_SECTOR_SIZE(pInst)        SD_CSD(pInst, 39,  7) ///< Erase sector size
    235          #define SD_CSD_WP_GRP_SIZE(pInst)        SD_CSD(pInst, 32,  7) ///< Write protect group size
    236          #define SD_CSD_WP_GRP_ENABLE(pInst)      SD_CSD(pInst, 31,  1) ///< write protect group enable
    237          #define SD_CSD_R2W_FACTOR(pInst)         SD_CSD(pInst, 26,  3) ///< Write speed factor
    238          #define SD_CSD_WRITE_BL_LEN(pInst)       SD_CSD(pInst, 22,  4) ///< Max write block length
    239          #define SD_CSD_WRITE_BL_PARTIAL(pInst)   SD_CSD(pInst, 21,  1) ///< Partial blocks for write allowed
    240          #define SD_CSD_FILE_FORMAT_GRP(pInst)    SD_CSD(pInst, 15,  1) ///< File format group
    241          #define SD_CSD_COPY(pInst)               SD_CSD(pInst, 14,  1) ///< Copy flag (OTP)
    242          #define SD_CSD_PERM_WRITE_PROTECT(pInst) SD_CSD(pInst, 13,  1) ///< Permanent write protect
    243          #define SD_CSD_TMP_WRITE_PROTECT(pInst)  SD_CSD(pInst, 12,  1) ///< Temporary write protection
    244          #define SD_CSD_FILE_FORMAT(pInst)        SD_CSD(pInst, 11,  2) ///< File format
    245          #define SD_CSD_CRC(pInst)                SD_CSD(pInst,  1,  7) ///< CRC
    246          #define SD_CSD_MULT(pInst)               (1 << (SD_CSD_C_SIZE_MULT(pInst) + 2))
    247          #define SD_CSD_BLOCKNR(pInst)            ((SD_CSD_C_SIZE(pInst) + 1) * SD_CSD_MULT(pInst))
    248          #define SD_CSD_BLOCKNR_HC(pInst)         ((SD_CSD_C_SIZE_HC(pInst) + 1) * 1024)
    249          #define SD_CSD_BLOCK_LEN(pInst)          (1 << SD_CSD_READ_BL_LEN(pInst))
    250          #define SD_CSD_TOTAL_SIZE(pInst)         (SD_CSD_BLOCKNR(pInst) * SD_CSD_BLOCK_LEN(pInst))
    251          #define SD_CSD_TOTAL_SIZE_HC(pInst)      ((SD_CSD_C_SIZE_HC(pInst) + 1) * 512* 1024)
    252          #define SD_TOTAL_BLOCK(pInst)            ((pInst)->NumSectors)
    253          
    254          // SCR register access macros.
    255          #define SD_SCR_BUS_WIDTHS(pScr)        ((pScr[1] >> 16) & 0xF) ///< Describes all the DAT bus that are supported by this card
    256          #define SD_SCR_BUS_WIDTH_4BITS         (1 << 1) ///< 4bit Bus Width is supported
    257          #define SD_SCR_BUS_WIDTH_1BIT          (1 << 0) ///< 1bit Bus Width is supported
    258          
    259          
    260          #define SD_CMD_POWER_ON_INIT              (0  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_INIT | MCI_CMDR_OPDCMD)
    261          //
    262          // Class 0 & 1 commands: Basic commands and Read Stream commands
    263          //
    264          #define SD_CMD_GO_IDLE_STATE              (0  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE)
    265          #define SD_CMD_MMC_GO_IDLE_STATE          (0  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_OPDCMD)
    266          #define SD_CMD_MMC_SEND_OP_COND           (1  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_OPDCMD)
    267          #define SD_CMD_ALL_SEND_CID               (2  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_136)
    268          #define SD_CMD_MMC_ALL_SEND_CID           (2  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_136  | MCI_CMDR_OPDCMD)
    269          #define SD_CMD_SET_RELATIVE_ADDR          (3  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_MAXLAT)
    270          #define SD_CMD_MMC_SET_RELATIVE_ADDR      (3  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_MAXLAT | MCI_CMDR_OPDCMD)
    271          #define SD_CMD_SET_DSR                    (4  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_NO   | MCI_CMDR_MAXLAT)    // not tested
    272          #define SD_CMD_SEL_DESEL_CARD             (7  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_MAXLAT)
    273          #define SD_CMD_SEND_IF_COND               (8  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_MAXLAT)
    274          #define SD_CMD_SEND_CSD                   (9  | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_136  | MCI_CMDR_MAXLAT)
    275          #define SD_CMD_SEND_CID                   (10 | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_136  | MCI_CMDR_MAXLAT)
    276          #define SD_CMD_MMC_READ_DAT_UNTIL_STOP    (11 | MCI_CMDR_TRTYP_STREAM| MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRDIR   | MCI_CMDR_TRCMD_START | MCI_CMDR_MAXLAT)
    277          #define SD_CMD_STOP_TRANSMISSION          (12 | MCI_CMDR_TRCMD_STOP  | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_MAXLAT)
    278          #define SD_CMD_STOP_TRANSMISSION_SYNC     (12 | MCI_CMDR_TRCMD_STOP  | MCI_CMDR_SPCMD_SYNC  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_MAXLAT)
    279          #define SD_CMD_SEND_STATUS                (13 | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_MAXLAT)
    280          #define SD_CMD_GO_INACTIVE_STATE          (15 | MCI_CMDR_RSPTYP_NO )
    281          #define SD_CMD_SET_BLOCKLEN               (16 | MCI_CMDR_TRCMD_NO    | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_MAXLAT)
    282          #define SD_CMD_READ_SINGLE_BLOCK          (17 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_START | MCI_CMDR_TRTYP_BLOCK     | MCI_CMDR_TRDIR   | MCI_CMDR_MAXLAT)
    283          #define SD_CMD_READ_MULTIPLE_BLOCK        (18 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_START | MCI_CMDR_TRTYP_MULTIPLE  | MCI_CMDR_TRDIR   | MCI_CMDR_MAXLAT)
    284          #define SD_CMD_WRITE_BLOCK                (24 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_START | (MCI_CMDR_TRTYP_BLOCK    &  ~(MCI_CMDR_TRDIR))  | MCI_CMDR_MAXLAT)
    285          #define SD_CMD_WRITE_MULTIPLE_BLOCK       (25 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_START | (MCI_CMDR_TRTYP_MULTIPLE &  ~(MCI_CMDR_TRDIR))  | MCI_CMDR_MAXLAT)
    286          #define SD_CMD_MMC_WRITE_DAT_UNTIL_STOP   (20 | MCI_CMDR_TRTYP_STREAM| MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48 & ~(MCI_CMDR_TRDIR) | MCI_CMDR_TRCMD_START | MCI_CMDR_MAXLAT) // MMC
    287          #define SD_CMD_WRITE_BLOCK                (24 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_START | (MCI_CMDR_TRTYP_BLOCK    &  ~(MCI_CMDR_TRDIR))  | MCI_CMDR_MAXLAT)
    288          #define SD_CMD_WRITE_MULTIPLE_BLOCK       (25 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_START | (MCI_CMDR_TRTYP_MULTIPLE &  ~(MCI_CMDR_TRDIR))  | MCI_CMDR_MAXLAT)
    289          #define SD_CMD_PROGRAM_CSD                (27 | MCI_CMDR_RSPTYP_48)
    290          #define SD_CMD_SET_WRITE_PROT             (28 | MCI_CMDR_RSPTYP_48)
    291          #define SD_CMD_CLR_WRITE_PROT             (29 | MCI_CMDR_RSPTYP_48)
    292          #define SD_CMD_SEND_WRITE_PROT            (30 | MCI_CMDR_RSPTYP_48)
    293          #define SD_CMD_TAG_SECTOR_START           (32 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT)
    294          #define SD_CMD_TAG_SECTOR_END             (33 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT)
    295          #define SD_CMD_MMC_UNTAG_SECTOR           (34 | MCI_CMDR_RSPTYP_48)
    296          #define SD_CMD_MMC_TAG_ERASE_GROUP_START  (35 | MCI_CMDR_RSPTYP_48)
    297          #define SD_CMD_MMC_TAG_ERASE_GROUP_END    (36 | MCI_CMDR_RSPTYP_48)
    298          #define SD_CMD_MMC_UNTAG_ERASE_GROUP      (37 | MCI_CMDR_RSPTYP_48)
    299          #define SD_CMD_ERASE                      (38 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT)
    300          #define SD_CMD_LOCK_UNLOCK                (42 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT) // not tested
    301          #define SD_CMD_APP                        (55 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT)
    302          #define SD_CMD_GEN                        (56 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT)    // not tested
    303          #define SD_CMD_APP_SET_BUS_WIDTH          (6  | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT)
    304          #define SD_CMD_APP_STATUS                 (13 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_START | MCI_CMDR_TRTYP_BLOCK | MCI_CMDR_TRDIR | MCI_CMDR_MAXLAT)
    305          #define SD_CMD_APP_SEND_NUM_WR_BLOCKS     (22 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT)
    306          #define SD_CMD_APP_SET_WR_BLK_ERASE_COUNT (23 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT)
    307          #define SD_CMD_APP_APP_OP_COND            (41 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO)
    308          #define SD_CMD_APP_SET_CLR_CARD_DETECT    (42 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT)
    309          #define SD_CMD_APP_SEND_SCR               (51 | MCI_CMDR_SPCMD_NONE  | MCI_CMDR_RSPTYP_48   | MCI_CMDR_TRCMD_NO    | MCI_CMDR_MAXLAT)
    310          
    311          #define CACHE_LINE_SIZE              32
    312          
    313          #define DELAY(x)                    { volatile int LooPs = x; do {} while(--LooPs); }
    314          /*********************************************************************
    315          *
    316          *       Defines, non-configurable
    317          *
    318          **********************************************************************
    319          */
    320          
    321          // Bit mask for Status register errors.
    322          #define STATUS_ERRORS (  MCI_STATUS_UNRE  \
    323                                 | MCI_STATUS_OVRE  \
    324                                 | MCI_STATUS_DTOE  \
    325                                 | MCI_STATUS_DCRCE \
    326                                 | MCI_STATUS_RTOE  \
    327                                 | MCI_STATUS_RENDE \
    328                                 | MCI_STATUS_RCRCE \
    329                                 | MCI_STATUS_RDIRE \
    330                                 | MCI_STATUS_RINDE)
    331          
    332          // MCI data timeout configuration with 1048576 MCK cycles between 2 data transfers.
    333          #define DTOR_1MEGA_CYCLES           (MCI_DTOR_DTOCYC | MCI_DTOR_DTOMUL)
    334          
    335          #define DISABLE                     (0)    // Disable MCI interface
    336          #define ENABLE                      (1)    // Enable MCI interface
    337          
    338          // Used to write in to a SFR register.
    339          #define WRITE_SFR_REG(pSFR, RegName, value)     pSFR->RegName = (value)
    340          // Used to read from a SFR register.
    341          #define READ_SFR_REG(pSFR, RegName)             (pSFR->RegName)
    342          
    343          
    344          /*********************************************************************
    345          *
    346          *       Type definitions
    347          *
    348          **********************************************************************
    349          */
    350          
    351          // MCI end-of-transfer callback function.
    352          typedef void (MCI_CALLBACK)(U8 Status, void * pCommand);
    353          
    354          //------------------------------------------------------------------------------
    355          /// MCI Transfer Request prepared by the application upper layer. This structure
    356          /// is sent to the __SendCommand function to start the transfer. At the end of
    357          /// the transfer, the callback is invoked by the interrupt handler.
    358          //------------------------------------------------------------------------------
    359          typedef struct _MCICMD {
    360            U32            Cmd;             // Command code.
    361            U32            Arg;             // Command argument.
    362            U16            SectorSize;      // Size of data buffer in bytes.
    363            U16            NumSectors;      // Number of Sector to be transfered
    364            U8             ConTrans;        // Indicate if continue to transfer data
    365            U8             IsRead;          // Indicates if the command is a read operation.
    366            U8             ResponseSize;    // Size of SD card response in bytes.
    367            U8             IsAppCmd;        // Specifies whether it is a Application command is or not
    368            volatile U8    Status;          // Command status.
    369            U8           * pData;           // Data buffer.
    370            U32          * pResp;           // Response buffer.
    371            MCI_CALLBACK * pfCallback;      // Optional user-provided callback function.
    372            void         * pArg;            // Optional argument to the callback function.
    373          } MCI_CMD;
    374          
    375          typedef struct MCI_HWREG {
    376            volatile U32 MCI_CR;        // MCI Control Register
    377            volatile U32 MCI_MR;        // MCI Mode Register
    378            volatile U32 MCI_DTOR;      // MCI Data Timeout Register
    379            volatile U32 MCI_SDCR;      // MCI SD Card Register
    380            volatile U32 MCI_ARGR;      // MCI Argument Register
    381            volatile U32 MCI_CMDR;      // MCI Command Register
    382            volatile U32 MCI_BLKR;      // MCI Block Register
    383            volatile U32 Reserved0[1];  //
    384            volatile U32 MCI_RSPR[4];   // MCI Response Register
    385            volatile U32 MCI_RDR;       // MCI Receive Data Register
    386            volatile U32 MCI_TDR;       // MCI Transmit Data Register
    387            volatile U32 Reserved1[2];  //
    388            volatile U32 MCI_SR;        // MCI Status Register
    389            volatile U32 MCI_IER;       // MCI Interrupt Enable Register
    390            volatile U32 MCI_IDR;       // MCI Interrupt Disable Register
    391            volatile U32 MCI_IMR;       // MCI Interrupt Mask Register
    392            volatile U32 Reserved2[43]; //
    393            volatile U32 MCI_VR;        // MCI Version Register
    394            volatile U32 MCI_RPR;       // Receive Pointer Register
    395            volatile U32 MCI_RCR;       // Receive Counter Register
    396            volatile U32 MCI_TPR;       // Transmit Pointer Register
    397            volatile U32 MCI_TCR;       // Transmit Counter Register
    398            volatile U32 MCI_RNPR;      // Receive Next Pointer Register
    399            volatile U32 MCI_RNCR;      // Receive Next Counter Register
    400            volatile U32 MCI_TNPR;      // Transmit Next Pointer Register
    401            volatile U32 MCI_TNCR;      // Transmit Next Counter Register
    402            volatile U32 MCI_PTCR;      // PDC Transfer Control Register
    403            volatile U32 MCI_PTSR;      // PDC Transfer Status Register
    404          } MCI_HWREG;
    405          
    406          
    407          typedef struct {
    408            U32         csd[4];               // Card-specific data.
    409            U32         PreSector;            // Previous access block number.
    410            U32         NumSectors;           // Card block number
    411            MCI_HWREG * pMciHw;               // Pointer to a MCI peripheral sfrs.
    412            MCI_CMD     Command;              // Current MCI command being processed.
    413            U16         CardAddress;          // SD card current address.
    414            U16         NumSectorsAtOnce;     // Number of sectors that can be transferred at once
    415            U8          IsInited;             // Specifies whether the driver is initialized or not.
    416            U8          State;                // State after SD command complete
    417            U8          CardType;             // Card type
    418            U8          IsWriteProtected;     // Write protection switch
    419            U8          Unit;
    420          } DRIVER_INST;
    421          
    422          /*********************************************************************
    423          *
    424          *       Static data
    425          *
    426          **********************************************************************
    427          */

   \                                 In section .bss, align 4
    428          static DRIVER_INST  * _apInst[NUM_UNITS];
   \                     _apInst:
   \   00000000                      DS8 8
   \   00000008                      DS8 4
   \   0000000C                      DS8 4
   \   00000010                      DS8 4
   \   00000014                      DS8 4
    429          static int            _NumUnits;
    430          //static U32            _aSectorBuffer[(NUM_SECTORS_AT_ONCE * SECTOR_SIZE + CACHE_LINE_SIZE) / 4];
    431          
    432          static U32 _NumSectorsAtOnce;
    433          static U32 _PAddrTransferMem;
    434          static U32 _VAddrTransferMem;

   \                                 In section .bss, align 4
   \   00000000                      DS8 4
    435          static U32 _TransferMemSize;
    436          
    437          /*********************************************************************
    438          *
    439          *       Static code
    440          *
    441          **********************************************************************
    442          */
    443          
    444          /*********************************************************************
    445          *
    446          *       _EnableMCI
    447          *
    448          *  Function description:
    449          *    Enable/disable a MCI driver instance.
    450          *
    451          *  Parameters:
    452          *    pInst    - Pointer to a MCI driver instance.
    453          *    Enable    - 0 for disable MCI and 1 for enable MCI.
    454          *
    455          *  Return value:
    456          *    void       -
    457          *
    458          */
    459          static void _EnableMCI(DRIVER_INST * pInst, U8 Enable) {
    460          	MCI_HWREG * pMciHw = pInst->pMciHw;
    461          
    462            // Set the Control Register: Enable/Disable MCI interface clock
    463            if(Enable == DISABLE) {
    464              WRITE_SFR_REG(pMciHw, MCI_CR, AT91C_MCI_MCIDIS);
    465            } else {
    466              WRITE_SFR_REG(pMciHw, MCI_CR, AT91C_MCI_MCIEN);
    467            }
    468          }
    469          
    470          /*********************************************************************
    471          *
    472          *       _OnSectorsRead
    473          *
    474          *  Function description:
    475          *    Callback function that is called whenever a data read transfer
    476          *    is taken.
    477          *    This makes sure that the ARM9 data cache is invalidated for the
    478          *    memory region, that the new data in memory will be reread.
    479          *
    480          *  Parameters:
    481          *    Status    - Status of the data transfer
    482          *    pCmd      - Pointer to the Command data structure.
    483          *
    484          *
    485          */

   \                                 In section .text, align 4, keep-with-next
    486          static void _OnSectorsRead(U8 Status, void * pCmd) {
   \                     _OnSectorsRead:
   \   00000000   0100A0E1           MOV      R0,R1
    487            U32  NumBytes;
    488            MCI_CMD * pCommand;
    489            U8 * p;
    490          
    491            FS_USE_PARA(Status);
    492            pCommand = (MCI_CMD *)pCmd;
    493            NumBytes = pCommand->SectorSize * pCommand->NumSectors;
    494            p = (U8 *)_VAddrTransferMem;
    495            FS_MEMCPY(pCommand->pData, p, NumBytes);
   \   00000004   B810D0E1           LDRH     R1,[R0, #+8]
   \   00000008   BA30D0E1           LDRH     R3,[R0, #+10]
   \   0000000C   140090E5           LDR      R0,[R0, #+20]
   \   00000010   930102E0           MUL      R2,R3,R1
   \   00000014   ........           LDR      R1,??DataTable4
   \   00000018   141091E5           LDR      R1,[R1, #+20]
   \   0000001C   ........           B        FS_memcpy        ;; tailcall
    496          }
    497          
    498          /*********************************************************************
    499          *
    500          *       _ISRHandler
    501          *
    502          *  Function description:
    503          *    This is the interrupt service routine for the MCI controller.
    504          *
    505          */

   \                                 In section .text, align 4, keep-with-next
    506          static void  _ISRHandler(void) {
   \                     _ISRHandler:
   \   00000000   00402DE9           PUSH     {LR}
    507            DRIVER_INST  * pInst;
    508            MCI_HWREG * pMciHw;
    509            MCI_CMD * pCommand;
    510            U32 Status;
    511            U8 i;
    512          
    513            pInst = _apInst[0];
   \   00000004   ........           LDR      R0,??DataTable4
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   002090E5           LDR      R2,[R0, #+0]
    514            pMciHw   = pInst->pMciHw;
   \   00000010   180092E5           LDR      R0,[R2, #+24]
    515            pCommand = &pInst->Command;
   \   00000014   1C1082E2           ADD      R1,R2,#+28
    516            //
    517            // Read the Status register
    518            //
    519            Status  = READ_SFR_REG(pMciHw, MCI_SR);
   \   00000018   403090E5           LDR      R3,[R0, #+64]
    520            Status &= READ_SFR_REG(pMciHw, MCI_IMR);
   \   0000001C   4CC090E5           LDR      R12,[R0, #+76]
   \   00000020   03300CE0           AND      R3,R12,R3
    521            //
    522            // Check if an error has occurred
    523            //
    524            if ((Status & STATUS_ERRORS) != 0) {
   \   00000024   C0C4A0E3           MOV      R12,#-1073741824
   \   00000028   7FC88CE3           ORR      R12,R12,#0x7F0000
   \   0000002C   03001CE1           TST      R12,R3
   \   00000030   0F00000A           BEQ      ??_ISRHandler_0
    525              //
    526              // Check error code
    527              //
    528              if ((Status & STATUS_ERRORS) == MCI_STATUS_RTOE) {
   \   00000034   03E00CE0           AND      LR,R12,R3
   \   00000038   40095EE3           CMP      LR,#+1048576
    529                pCommand->Status = MCI_STATUS_NORESPONSE;
   \   0000003C   03C0A003           MOVEQ    R12,#+3
   \   00000040   0A00000A           BEQ      ??_ISRHandler_1
    530              }
    531              // if the command is SEND_OP_COND the CRC error flag is always present
    532              // (cf : R3 response)
    533              else if (((Status & STATUS_ERRORS) != MCI_STATUS_RCRCE) || ((pCommand->Cmd != SD_CMD_APP_APP_OP_COND) && (pCommand->Cmd != SD_CMD_MMC_SEND_OP_COND))) {
   \   00000044   03C00CE0           AND      R12,R12,R3
   \   00000048   400A5CE3           CMP      R12,#+262144
   \   0000004C   0600001A           BNE      ??_ISRHandler_2
   \   00000050   00C091E5           LDR      R12,[R1, #+0]
   \   00000054   69005CE3           CMP      R12,#+105
   \   00000058   0500000A           BEQ      ??_ISRHandler_0
   \   0000005C   41E0A0E3           MOV      LR,#+65
   \   00000060   80EE8EE3           ORR      LR,LR,#0x800
   \   00000064   0E005CE1           CMP      R12,LR
   \   00000068   0100000A           BEQ      ??_ISRHandler_0
    534                pCommand->Status = MCI_STATUS_ERROR;
   \                     ??_ISRHandler_2:
   \   0000006C   02C0A0E3           MOV      R12,#+2
   \                     ??_ISRHandler_1:
   \   00000070   10C0C1E5           STRB     R12,[R1, #+16]
    535              }
    536            }
    537            // Check if a transfer has been completed
    538            if (((Status & MCI_STATUS_CMDRDY) != 0)  || ((Status & MCI_STATUS_ENDRX) != 0) ||
    539                ((Status & MCI_STATUS_RXBUFF) != 0)  || ((Status & MCI_STATUS_ENDTX) != 0) ||
    540                ((Status & MCI_STATUS_BLKE)   != 0)  || ((Status & MCI_STATUS_RTOE) != 0)) {
   \                     ??_ISRHandler_0:
   \   00000074   C9C0A0E3           MOV      R12,#+201
   \   00000078   41C98CE3           ORR      R12,R12,#0x104000
   \   0000007C   03001CE1           TST      R12,R3
   \   00000080   1E00000A           BEQ      ??_ISRHandler_3
    541              if (((Status & MCI_STATUS_ENDRX) != 0) || ((Status & MCI_STATUS_RXBUFF) != 0) || ((Status & MCI_STATUS_ENDTX) != 0)) {
   \   00000084   C0C0A0E3           MOV      R12,#+192
   \   00000088   40CC8CE3           ORR      R12,R12,#0x4000
   \   0000008C   03001CE1           TST      R12,R3
    542                _EnableMCI(pInst, DISABLE);
   \   00000090   0230A013           MOVNE    R3,#+2
   \   00000094   00308015           STRNE    R3,[R0, #+0]
    543              }
    544              // If no error occurred, the transfer is successful
    545              if (pCommand->Status == MCI_STATUS_PENDING) {
   \   00000098   1020D1E5           LDRB     R2,[R1, #+16]
   \   0000009C   010052E3           CMP      R2,#+1
    546                pCommand->Status = 0;
   \   000000A0   0020A003           MOVEQ    R2,#+0
   \   000000A4   1020C105           STRBEQ   R2,[R1, #+16]
    547              }
    548              // Store the card response in the provided buffer
    549              if (pCommand->pResp) {
   \   000000A8   182091E5           LDR      R2,[R1, #+24]
   \   000000AC   000052E3           CMP      R2,#+0
   \   000000B0   0B00000A           BEQ      ??_ISRHandler_4
    550                for (i=0; i < pCommand->ResponseSize; i++) {
   \   000000B4   0EC0D1E5           LDRB     R12,[R1, #+14]
   \   000000B8   0030A0E3           MOV      R3,#+0
   \   000000BC   00005CE3           CMP      R12,#+0
   \   000000C0   0700000A           BEQ      ??_ISRHandler_4
    551                  pCommand->pResp[i] = READ_SFR_REG(pMciHw, MCI_RSPR[0]);
   \                     ??_ISRHandler_5:
   \   000000C4   20E090E5           LDR      LR,[R0, #+32]
   \   000000C8   03C0A0E1           MOV      R12,R3
   \   000000CC   0CE182E7           STR      LR,[R2, +R12, LSL #+2]
    552                }
   \   000000D0   0EC0D1E5           LDRB     R12,[R1, #+14]
   \   000000D4   013083E2           ADD      R3,R3,#+1
   \   000000D8   FF3003E2           AND      R3,R3,#0xFF
   \   000000DC   0C0053E1           CMP      R3,R12
   \   000000E0   F7FFFF3A           BCC      ??_ISRHandler_5
    553              }
    554              //
    555              // Disable interrupt
    556              //
    557              WRITE_SFR_REG(pMciHw, MCI_IDR, READ_SFR_REG(pMciHw, MCI_IMR));
   \                     ??_ISRHandler_4:
   \   000000E4   4C2090E5           LDR      R2,[R0, #+76]
   \   000000E8   482080E5           STR      R2,[R0, #+72]
    558              //
    559              // Invoke the callback associated with the current command (if any)
    560              //
    561              if (pCommand->pfCallback) {
   \   000000EC   1C2091E5           LDR      R2,[R1, #+28]
   \   000000F0   000052E3           CMP      R2,#+0
   \   000000F4   0100000A           BEQ      ??_ISRHandler_3
    562                (pCommand->pfCallback)(pCommand->Status, (void *)pCommand);
   \   000000F8   1000D1E5           LDRB     R0,[R1, #+16]
   \   000000FC   32FF2FE1           BLX      R2
    563              }
    564            }
    565            //
    566            // Wake task (in case it is waiting for completion interrupt)
    567            //
    568            FS_OS_SIGNAL();
   \                     ??_ISRHandler_3:
   \   00000100   04D08DE2           ADD      SP,SP,#+4
   \   00000104   0040BDE8           POP      {LR}
   \   00000108   ........           B        FS_X_OS_Signal   ;; tailcall
    569          }
    570          
    571          /*********************************************************************
    572          *
    573          *       _CmdCompleted
    574          *
    575          *  Function description:
    576          *    Returns information, whether command has been successfully sent and processed.
    577          *
    578          *  Parameters:
    579          *    pCommand    -
    580          *
    581          *  Return value:
    582          *    1       - Command completed
    583          *    0       - Command is still being processed
    584          *
    585          */
    586          static U8 _CmdCompleted(MCI_CMD * pCommand) {
    587            if (pCommand->Status != MCI_STATUS_PENDING) {
    588              if (pCommand->Status != 0) {
    589                FS_DEBUG_LOG((FS_MTYPE_DRIVER, "MCI_IsTxComplete %d\n\r", pCommand->Status));
    590              }
    591              return 1;
    592            } else {
    593              return 0;
    594            }
    595          }
    596          
    597          
    598          /*********************************************************************
    599          *
    600          *       __SendCommand
    601          *
    602          *  Function description:
    603          *    Starts a MCI  transfer. This is a non blocking function. It will return
    604          *    as soon as the transfer is started.
    605          *
    606          *  Parameters:
    607          *    pInst    - Pointer to a MCI driver instance.
    608          *    pCommand    - Pointer the to command structure.
    609          *
    610          *  Return value:
    611          *    0       - Command completed successfully
    612          *
    613          */

   \                                 In section .text, align 4, keep-with-next
    614          static U8 __SendCommand(DRIVER_INST * pInst) {
   \                     __SendCommand:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    615            U32          mciIer, ModeReg;
    616            U32          NumBytes;
    617            U8         * p;
    618            MCI_HWREG  * pMciHw = pInst->pMciHw;
   \   00000008   185094E5           LDR      R5,[R4, #+24]
    619            MCI_CMD    * pCommand = &pInst->Command;
   \   0000000C   1C6084E2           ADD      R6,R4,#+28
    620            //
    621            // Command is now being executed
    622            //
    623            pCommand->Status = MCI_STATUS_PENDING;
   \   00000010   0170A0E3           MOV      R7,#+1
   \   00000014   1070C6E5           STRB     R7,[R6, #+16]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
    624            //
    625            //  Update hardware regs
    626            //
    627            FS_MCI_HW_EnableClock(pInst->Unit, 1);                        // Enable the MCI clock
   \   0000001C   0110A0E3           MOV      R1,#+1
   \   00000020   4800D4E5           LDRB     R0,[R4, #+72]
   \   00000024   ........           BL       FS_MCI_HW_EnableClock
    628            _EnableMCI(pInst, DISABLE);                            //Disable MCI clock, for multi-block data transfer
   \   00000028   180094E5           LDR      R0,[R4, #+24]
   \   0000002C   0210A0E3           MOV      R1,#+2
   \   00000030   001080E5           STR      R1,[R0, #+0]
    629            //
    630            // Setup PDC data transfer direction
    631            //
    632            if(pCommand->SectorSize > 0) {
   \   00000034   B800D6E1           LDRH     R0,[R6, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0400000A           BEQ      ??__SendCommand_0
    633              if(pCommand->IsRead) {
   \   00000040   0D10D6E5           LDRB     R1,[R6, #+13]
   \   00000044   000051E3           CMP      R1,#+0
    634                WRITE_SFR_REG(pMciHw, MCI_PTCR, AT91C_PDC_RXTEN);
   \   00000048   20718515           STRNE    R7,[R5, #+288]
    635              } else {
    636                WRITE_SFR_REG(pMciHw, MCI_PTCR, AT91C_PDC_TXTEN);
   \   0000004C   401FA003           MOVEQ    R1,#+256
   \   00000050   20118505           STREQ    R1,[R5, #+288]
    637              }
    638            }
    639            WRITE_SFR_REG(pMciHw, MCI_PTCR, AT91C_PDC_RXTDIS | AT91C_PDC_TXTDIS);  // Disable transmitter and receiver
   \                     ??__SendCommand_0:
   \   00000054   0210A0E3           MOV      R1,#+2
   \   00000058   801F81E3           ORR      R1,R1,#0x200
   \   0000005C   201185E5           STR      R1,[R5, #+288]
    640            ModeReg = READ_SFR_REG(pMciHw, MCI_MR) & (~(AT91C_MCI_BLKLEN | AT91C_MCI_PDCMODE));
   \   00000060   041095E5           LDR      R1,[R5, #+4]
    641            //
    642            // Command with DATA stage
    643            //
    644            if (pCommand->SectorSize > 0) {
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   8118A0E1           LSL      R1,R1,#+17
   \   0000006C   A118A0E1           LSR      R1,R1,#+17
   \   00000070   2400000A           BEQ      ??__SendCommand_1
    645              // Enable PDC mode and set block size
    646              if(pCommand->ConTrans != MCI_CONTINUE_TRANSFER) {
   \   00000074   0C20D6E5           LDRB     R2,[R6, #+12]
   \   00000078   010052E3           CMP      R2,#+1
    647                WRITE_SFR_REG(pMciHw, MCI_MR, ModeReg | AT91C_MCI_PDCMODE | (pCommand->SectorSize << 16));
   \   0000007C   00188111           ORRNE    R1,R1,R0, LSL #+16
   \   00000080   801C8113           ORRNE    R1,R1,#0x8000
   \   00000084   04108515           STRNE    R1,[R5, #+4]
    648              }
    649              // DATA transfer from card to host
    650              if (pCommand->IsRead) {
   \   00000088   0D20D6E5           LDRB     R2,[R6, #+13]
   \   0000008C   BA10D6E1           LDRH     R1,[R6, #+10]
   \   00000090   000052E3           CMP      R2,#+0
   \   00000094   0C00000A           BEQ      ??__SendCommand_2
    651                //
    652                // We always copy from our temporary buffer to the final one
    653                // It is not necessary to check if the final buffer can also be used by the DMA since
    654                // a) There should not be a big performance difference if we write directly into
    655                //    the final buffer or writing into our temporary buffer first and them copying it to the final one
    656                // b) In general we should always let the DMA write in our temporary buffer, since this memory is
    657                //    guaranteed to be fast enough so there are no problems that the DMA is blocked too long (by other tasks which use the same memory)
    658                //
    659                NumBytes = pCommand->SectorSize * pCommand->NumSectors;
   \   00000098   910008E0           MUL      R8,R1,R0
    660                WRITE_SFR_REG(pMciHw, MCI_RPR, _PAddrTransferMem);
   \   0000009C   ........           LDR      R0,??DataTable4
    661                pCommand->pfCallback = _OnSectorsRead;
    662                //
    663                // Sanity checks
    664                //
    665                if (pCommand->NumSectors == 0) {
   \   000000A0   000051E3           CMP      R1,#+0
   \   000000A4   100090E5           LDR      R0,[R0, #+16]
   \   000000A8   000185E5           STR      R0,[R5, #+256]
   \   000000AC   ........           LDR      R0,??DataTable4_1
   \   000000B0   1C0086E5           STR      R0,[R6, #+28]
    666                  pCommand->NumSectors = 1;
   \   000000B4   BA70C601           STRHEQ   R7,[R6, #+10]
    667                }
    668                WRITE_SFR_REG(pMciHw, MCI_RCR, NumBytes / 4);
   \   000000B8   2801A0E1           LSR      R0,R8,#+2
   \   000000BC   040185E5           STR      R0,[R5, #+260]
    669                WRITE_SFR_REG(pMciHw, MCI_PTCR, AT91C_PDC_RXTEN);
   \   000000C0   207185E5           STR      R7,[R5, #+288]
    670                mciIer = MCI_STATUS_ENDRX | STATUS_ERRORS;
   \   000000C4   ........           LDR      R0,??DataTable4_2  ;; 0xc07f0040
   \   000000C8   110000EA           B        ??__SendCommand_3
    671              } else {  // DATA transfer from host to card
    672                // Sanity check
    673                if (pCommand->NumSectors == 0) {
   \                     ??__SendCommand_2:
   \   000000CC   000051E3           CMP      R1,#+0
    674                  pCommand->NumSectors = 1;
   \   000000D0   BA70C601           STRHEQ   R7,[R6, #+10]
    675                }
    676                NumBytes = pCommand->SectorSize * pCommand->NumSectors;
   \   000000D4   BA10D6E1           LDRH     R1,[R6, #+10]
    677                FS_MEMCPY((U8 *)_VAddrTransferMem, pCommand->pData, NumBytes);
   \   000000D8   ........           LDR      R9,??DataTable4
   \   000000DC   910008E0           MUL      R8,R1,R0
   \   000000E0   141096E5           LDR      R1,[R6, #+20]
   \   000000E4   0820A0E1           MOV      R2,R8
   \   000000E8   140099E5           LDR      R0,[R9, #+20]
   \   000000EC   ........           BL       FS_memcpy
    678                WRITE_SFR_REG(pMciHw, MCI_TPR, _PAddrTransferMem);
   \   000000F0   100099E5           LDR      R0,[R9, #+16]
   \   000000F4   080185E5           STR      R0,[R5, #+264]
    679          /*
    680                if ((((U32)pCommand->pData & 0x1f)) || (NumBytes & 0x1f)) {
    681                  p = _GetBufferAddr();
    682                  FS_MEMCPY(p, pCommand->pData, NumBytes);
    683                } else {
    684                  p = pCommand->pData;
    685                }
    686                WRITE_SFR_REG(pMciHw, MCI_TPR, (int)p);
    687          */
    688                //
    689                // Update the PDC counter
    690                //
    691                WRITE_SFR_REG(pMciHw, MCI_TCR, (NumBytes) / 4);
   \   000000F8   2801A0E1           LSR      R0,R8,#+2
   \   000000FC   0C0185E5           STR      R0,[R5, #+268]
    692                // MCI_BLKE notifies the end of Multiblock command
    693                mciIer = MCI_STATUS_BLKE | STATUS_ERRORS;
   \   00000100   8C02A0E3           MOV      R0,#-1073741816
   \   00000104   010000EA           B        ??__SendCommand_4
    694              }
    695            } else {  // No data transfer: stop at the end of the command
    696              WRITE_SFR_REG(pMciHw, MCI_MR, ModeReg);
   \                     ??__SendCommand_1:
   \   00000108   041085E5           STR      R1,[R5, #+4]
    697              mciIer = MCI_STATUS_CMDRDY | STATUS_ERRORS;
   \   0000010C   7003A0E3           MOV      R0,#-1073741823
   \                     ??__SendCommand_4:
   \   00000110   7F0880E3           ORR      R0,R0,#0x7F0000
    698            }
    699            //
    700            // Enable MCI clock
    701            //
    702            _EnableMCI(pInst, ENABLE);
   \                     ??__SendCommand_3:
   \   00000114   181094E5           LDR      R1,[R4, #+24]
   \   00000118   007081E5           STR      R7,[R1, #+0]
    703            //
    704            // Send the command
    705            //
    706            if((pCommand->ConTrans != MCI_CONTINUE_TRANSFER) || (pCommand->SectorSize == 0)) {
   \   0000011C   0C10D6E5           LDRB     R1,[R6, #+12]
   \   00000120   010051E3           CMP      R1,#+1
   \   00000124   0200001A           BNE      ??__SendCommand_5
   \   00000128   B810D6E1           LDRH     R1,[R6, #+8]
   \   0000012C   000051E3           CMP      R1,#+0
   \   00000130   0300001A           BNE      ??__SendCommand_6
    707              WRITE_SFR_REG(pMciHw, MCI_ARGR, pCommand->Arg);
   \                     ??__SendCommand_5:
   \   00000134   041096E5           LDR      R1,[R6, #+4]
   \   00000138   101085E5           STR      R1,[R5, #+16]
    708              WRITE_SFR_REG(pMciHw, MCI_CMDR, pCommand->Cmd);
   \   0000013C   001096E5           LDR      R1,[R6, #+0]
   \   00000140   141085E5           STR      R1,[R5, #+20]
    709            }
    710            //
    711            // In case of transmit, the PDC shall be enabled after sending the command
    712            //
    713            if ((pCommand->SectorSize > 0) && !(pCommand->IsRead)) {
   \                     ??__SendCommand_6:
   \   00000144   B810D6E1           LDRH     R1,[R6, #+8]
   \   00000148   000051E3           CMP      R1,#+0
   \   0000014C   0300000A           BEQ      ??__SendCommand_7
   \   00000150   0D10D6E5           LDRB     R1,[R6, #+13]
   \   00000154   000051E3           CMP      R1,#+0
    714              WRITE_SFR_REG(pMciHw, MCI_PTCR, AT91C_PDC_TXTEN);
   \   00000158   401FA003           MOVEQ    R1,#+256
   \   0000015C   20118505           STREQ    R1,[R5, #+288]
    715            }
    716            //
    717            // Ignore data error
    718            //
    719            mciIer &= ~(MCI_STATUS_UNRE | MCI_STATUS_OVRE | MCI_STATUS_DTOE | MCI_STATUS_DCRCE);
    720            //
    721            // Interrupt enable shall be done after PDC TXTEN and RXTEN
    722            //
    723            WRITE_SFR_REG(pMciHw, MCI_IER, mciIer);
   \                     ??__SendCommand_7:
   \   00000160   C014E0E3           MVN      R1,#-1073741824
   \   00000164   6018C1E3           BIC      R1,R1,#0x600000
   \   00000168   000001E0           AND      R0,R1,R0
   \   0000016C   440085E5           STR      R0,[R5, #+68]
   \   00000170   010000EA           B        ??__SendCommand_8
    724            //
    725            // Wait for command to complete
    726            // As long as the PDC sends data, pCommand->Status does not change.
    727            // As soon as the PDC is finished, an interrupt is generated and _ISRHandler() is called.
    728            // This function will alter the pCommand->Status variable.
    729            //
    730            while(_CmdCompleted(pCommand) == 0) {
    731              FS_OS_WAIT(1000);
   \                     ??__SendCommand_9:
   \   00000174   FA0FA0E3           MOV      R0,#+1000
   \   00000178   ........           BL       FS_X_OS_Wait
    732            }
   \                     ??__SendCommand_8:
   \   0000017C   1000D6E5           LDRB     R0,[R6, #+16]
   \   00000180   010050E3           CMP      R0,#+1
   \   00000184   FAFFFF0A           BEQ      ??__SendCommand_9
   \   00000188   1000D6E5           LDRB     R0,[R6, #+16]
    733            return 0;
   \   0000018C   04D08DE2           ADD      SP,SP,#+4
   \   00000190   0000A0E3           MOV      R0,#+0
   \   00000194   F083BDE8           POP      {R4-R9,PC}       ;; return
    734          }
    735          
    736          /*********************************************************************
    737          *
    738          *       _InitMCI
    739          *
    740          *  Function description:
    741          *    Initializes a MCI driver instance and the underlying peripheral
    742          *
    743          *  Return value:
    744          *    Returns a pointer to a MCI instance.
    745          *
    746          */
    747          static void _InitMCI(DRIVER_INST * pInst){
    748            unsigned    ClkDiv;
    749            U32         Mode;
    750            MCI_INFO    Info;
    751            MCI_HWREG * pMciHw;
    752          
    753            FS_MCI_HW_Init(pInst->Unit);
    754            FS_MCI_HW_GetMCIInfo(pInst->Unit, &Info);
    755            Mode   = Info.Mode;
    756            pMciHw = (MCI_HWREG *)Info.BaseAddr;
    757            // Initialize the MCI driver structure
    758            pInst->pMciHw   = pMciHw;
    759            FS_MCI_HW_EnableClock(pInst->Unit, ENABLE);                                // Enable the MCI clock
    760            WRITE_SFR_REG(pMciHw, MCI_CR, AT91C_MCI_SWRST);        // Reset the MCI
    761            WRITE_SFR_REG(pMciHw, MCI_CR, AT91C_MCI_MCIDIS | AT91C_MCI_PWSDIS);  // Disable the MCI
    762            WRITE_SFR_REG(pMciHw, MCI_IDR, 0xFFFFFFFF);                          // Disable all the interrupts
    763            WRITE_SFR_REG(pMciHw, MCI_DTOR, DTOR_1MEGA_CYCLES);                  // Set the Data Timeout Register
    764            ClkDiv = (FS_MCI_HW_GetMClk(pInst->Unit) / (400000 * 2)) - 1;                         // Set the Mode Register: 400KHz for MCK = 48MHz (CLKDIV = 58)
    765            WRITE_SFR_REG(pMciHw, MCI_MR, (ClkDiv | (AT91C_MCI_PWSDIV & (0x7 << 8))));
    766            WRITE_SFR_REG(pMciHw, MCI_SDCR, Mode);                               // Set the SDCard Register
    767            WRITE_SFR_REG(pMciHw, MCI_CR, AT91C_MCI_MCIEN);                      // Enable the MCI and the Power Saving
    768            FS_MCI_HW_EnableClock(pInst->Unit, DISABLE);                                               // Disable the MCI peripheral clock.
    769            FS_MCI_HW_EnableISR(pInst->Unit, _ISRHandler);
    770          }
    771          
    772          /*********************************************************************
    773          *
    774          *       _CloseMCI
    775          *
    776          *  Function description:
    777          *    Close a MCI driver instance and the underlying peripheral.
    778          *
    779          *  Parameters:
    780          *    pInst    - Pointer to a MCI driver instance.
    781          *
    782          */
    783          static void _CloseMCI(DRIVER_INST * pInst) {
    784            MCI_HWREG * pMciHw = pInst->pMciHw;
    785          
    786            //
    787            // Initialize the MCI driver structure
    788            //
    789            FS_OS_SIGNAL();
    790          //  pInst->Command  = NULL;
    791            //
    792            //  Disable Hardware
    793            //
    794            FS_MCI_HW_EnableClock(pInst->Unit, 0);
    795            WRITE_SFR_REG(pMciHw, MCI_CR, AT91C_MCI_MCIDIS);           // Disable the MCI
    796            WRITE_SFR_REG(pMciHw, MCI_IDR, 0xFFFFFFFF);                // Disable all the interrupts
    797          }
    798          
    799          /*********************************************************************
    800          *
    801          *       MCI_SetBusWidth
    802          *
    803          *  Function description:
    804          *    Configure the  MCI SDCBUS in the MCI_SDCR register. Only two modes available
    805          *
    806          *  Parameters:
    807          *    pInst    - Pointer to a MCI driver instance.
    808          *    BusWidth    - MCI_SDCBUS_1BIT or MCI_SDCBUS_4BIT
    809          *
    810          */
    811          static void _SetBusWidth(DRIVER_INST * pInst, U8 BusWidth) {
    812            MCI_HWREG * pMciHw = pInst->pMciHw;
    813            U32 mciSdcr;
    814          
    815            mciSdcr = (READ_SFR_REG(pMciHw, MCI_SDCR) & ~(MCI_SDCR_SCDBUS));
    816            WRITE_SFR_REG(pMciHw, MCI_SDCR, mciSdcr | BusWidth);
    817          }
    818          
    819          
    820          /*********************************************************************
    821          *
    822          *       MCI_CheckBusy
    823          *
    824          *  Function description:
    825          *    Check NOTBUSY and DTIP bits of Status register on the given MCI driver.
    826          *
    827          *  Parameters:
    828          *    pInst    - Pointer to a MCI driver instance.
    829          *
    830          *  Return value:
    831          *    0           - Bus is ready
    832          *    1           - Bus is busy
    833          *
    834          */
    835          static U8 _CheckBusy(DRIVER_INST * pInst) {
    836            U32 Status;
    837            MCI_HWREG * pMciHw = pInst->pMciHw;
    838          
    839            // Enable MCI clock
    840            _EnableMCI(pInst, ENABLE);
    841            Status = READ_SFR_REG(pMciHw, MCI_SR);
    842            if(((Status & MCI_STATUS_NOTBUSY)!=0) && ((Status & MCI_STATUS_DTIP)==0)) {
    843              // Disable MCI clock
    844              _EnableMCI(pInst, DISABLE);
    845              return 0;
    846            } else {
    847              return 1;
    848            }
    849          }
    850          
    851          /*********************************************************************
    852          *
    853          *       MCI_SetSpeed
    854          *
    855          *  Function description:
    856          *    Configure the  MCI CLKDIV in the MCI_MR register. The max.
    857          *    for MCI clock is MCK/2 and corresponds to CLKDIV = 0
    858          *
    859          *  Parameters:
    860          *    pInst    - Pointer to a MCI driver instance.
    861          *    Frequency   - Frequency given in Hz.
    862          *
    863          */
    864          static void MCI_SetSpeed(DRIVER_INST * pInst, U32 Frequency) {
    865            U32         ModeReg;
    866            unsigned    ClkDiv;
    867            MCI_HWREG * pMciHw = pInst->pMciHw;
    868          
    869            // Set the Mode Register: 400KHz for MCK = 48MHz (CLKDIV = 58)
    870            ModeReg = READ_SFR_REG(pMciHw, MCI_MR) & (~AT91C_MCI_CLKDIV);
    871            // Multimedia Card Interface clock (MCCK or MCI_CK) is Master Clock (MCK)
    872            // divided by (2*(CLKDIV+1))
    873            if (Frequency > 0) {
    874              ClkDiv = (FS_MCI_HW_GetMClk(pInst->Unit) / (Frequency * 2));
    875              if (ClkDiv > 0) {
    876                ClkDiv -= 1;
    877              }
    878            } else {
    879               ClkDiv= 0;
    880            }
    881            WRITE_SFR_REG(pMciHw, MCI_MR, ModeReg | ClkDiv);
    882          }
    883          
    884          
    885          
    886          /*********************************************************************
    887          *
    888          *       _SendCommand
    889          *
    890          *  Function description:
    891          *    Sends the current SD card driver command to the card.
    892          *
    893          *  Parameters:
    894          *    pInst    - Pointer to a DRIVER_INST driver instance.
    895          *
    896          *  Return value:
    897          *    0          - if successful;
    898          *    != 0       - Returns the transfer Status code or SD_ERROR_MCI
    899          *                 if there was a problem with the MCI transfer.
    900          *
    901          */
    902          static U8 _SendCommand(DRIVER_INST * pInst) {
    903            MCI_CMD * pCommand = &(pInst->Command);
    904            U8        Error;
    905          
    906            //
    907            // Send command
    908            //
    909            Error = __SendCommand(pInst);
    910            if (Error) {
    911              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "SendCommand: Failed to send command (%d)\n\r", Error));
    912              return SD_ERROR_MCI;
    913            }
    914            if(pCommand->Cmd == SD_CMD_STOP_TRANSMISSION) {
    915              while (_CheckBusy(pInst) != 0);
    916            }
    917            //
    918            // Delay between sending commands, only for MMC card test.
    919            //
    920            if((pInst->CardType == CARD_MMC)||(pInst->CardType == UNKNOWN_CARD)) {
    921              int i;
    922              for(i=0; i < MMC_DELAY; i++);
    923            }
    924            return pCommand->Status;
    925          }
    926          
    927          /*********************************************************************
    928          *
    929          *       _PowerOn
    930          *
    931          *  Function description:
    932          *    Initialization delay: The maximum of 1 msec, 74 clock cycles and supply ramp
    933          *    up time.
    934          *
    935          *  Parameters:
    936          *    pInst    - Pointer to a SD card driver instance.
    937          *
    938          *  Return value:
    939          *     Returns 0 if successful
    940          *     Otherwise returns an code describing the Error.
    941          *
    942          */
    943          static U8 _PowerOn(DRIVER_INST * pInst) {
    944            U8 r;
    945            MCI_CMD *pCommand = &(pInst->Command);
    946          
    947            ZEROFILL(pCommand, sizeof(MCI_CMD));
    948            //
    949            // Fill command information
    950            //
    951            pCommand->Cmd = SD_CMD_POWER_ON_INIT;
    952            //
    953            // Set SD command state
    954            //
    955            pInst->State = SD_STATE_STBY;
    956            //
    957            // Send command
    958            //
    959            r = _SendCommand(pInst);
    960            DELAY(200);
    961            return r;
    962          }
    963          
    964          /*********************************************************************
    965          *
    966          *       _SendCMD0
    967          *
    968          *  Function description:
    969          *    Resets all cards to idle state.
    970          *
    971          *  Parameters:
    972          *    pInst    - Pointer to a SD card driver instance.
    973          *
    974          *  Return value:
    975          *     Returns 0 if successful
    976          *     Otherwise returns an code describing the Error.
    977          *
    978          */
    979          static U8 _SendCMD0(DRIVER_INST * pInst) {
    980            U8       r;
    981            MCI_CMD *pCommand = &(pInst->Command);
    982          
    983            ZEROFILL(pCommand, sizeof(MCI_CMD));
    984            //
    985            // Fill command information
    986            //
    987            pCommand->Cmd = SD_CMD_GO_IDLE_STATE;
    988            //
    989            // Set SD command state
    990            //
    991            pInst->State = SD_STATE_STBY;
    992            //
    993            // Send command
    994            //
    995            r = _SendCommand(pInst);
    996            DELAY(200);
    997            return r;
    998          }
    999          
   1000          /*********************************************************************
   1001          *
   1002          *       _SendCMD1
   1003          *
   1004          *  Function description:
   1005          *    MMC send operation condition command.
   1006          *
   1007          *  Parameters:
   1008          *    pInst    - Pointer to a SD card driver instance.
   1009          *
   1010          *  Return value:
   1011          *     Returns 0 if successful
   1012          *     Otherwise returns an code describing the Error.
   1013          *
   1014          */

   \                                 In section .text, align 4, keep-with-next
   1015          static U8 _SendCMD1(DRIVER_INST * pInst) {
   \                     _SendCMD1:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1016            U8        Error;
   1017            U32       Response;
   1018            MCI_CMD * pCommand = &(pInst->Command);
   \   00000008   1C5084E2           ADD      R5,R4,#+28
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
   1019          
   1020            ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   00000010   2410A0E3           MOV      R1,#+36
   \   00000014   0500A0E1           MOV      R0,R5
   \   00000018   ........           BL       __aeabi_memclr4
   1021            //
   1022            // Fill command information
   1023            //
   1024            pCommand->Cmd          = SD_CMD_MMC_SEND_OP_COND;
   \   0000001C   4100A0E3           MOV      R0,#+65
   \   00000020   800E80E3           ORR      R0,R0,#0x800
   \   00000024   000085E5           STR      R0,[R5, #+0]
   1025            pCommand->Arg          = MMC_HOST_VOLTAGE_RANGE;
   \   00000028   7E09A0E3           MOV      R0,#+2064384
   \   0000002C   040085E5           STR      R0,[R5, #+4]
   1026            pCommand->ResponseSize = 1;
   \   00000030   0160A0E3           MOV      R6,#+1
   \   00000034   0E60C5E5           STRB     R6,[R5, #+14]
   1027            pCommand->pResp        = &Response;
   \   00000038   18D085E5           STR      SP,[R5, #+24]
   1028            //
   1029            // Set SD command state
   1030            //
   1031            pInst->State = SD_STATE_STBY;
   \   0000003C   0000A0E3           MOV      R0,#+0
   \   00000040   4500C4E5           STRB     R0,[R4, #+69]
   1032            //
   1033            // Send command
   1034            //
   1035            Error = _SendCommand(pInst);
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       __SendCommand
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0F00001A           BNE      ??_SendCMD1_0
   \   00000054   000095E5           LDR      R0,[R5, #+0]
   \   00000058   4C10A0E3           MOV      R1,#+76
   \   0000005C   841B81E3           ORR      R1,R1,#0x21000
   \   00000060   010050E1           CMP      R0,R1
   \   00000064   0700001A           BNE      ??_SendCMD1_1
   \                     ??_SendCMD1_2:
   \   00000068   180094E5           LDR      R0,[R4, #+24]
   \   0000006C   006080E5           STR      R6,[R0, #+0]
   \   00000070   401090E5           LDR      R1,[R0, #+64]
   \   00000074   301001E2           AND      R1,R1,#0x30
   \   00000078   200051E3           CMP      R1,#+32
   \   0000007C   F9FFFF1A           BNE      ??_SendCMD1_2
   \   00000080   0210A0E3           MOV      R1,#+2
   \   00000084   001080E5           STR      R1,[R0, #+0]
   \                     ??_SendCMD1_1:
   \   00000088   1060D5E5           LDRB     R6,[R5, #+16]
   1036            if (Error) {
   \   0000008C   000056E3           CMP      R6,#+0
   \   00000090   0100000A           BEQ      ??_SendCMD1_3
   1037              return Error;
   \                     ??_SendCMD1_0:
   \   00000094   0600A0E1           MOV      R0,R6
   \   00000098   030000EA           B        ??_SendCMD1_4
   1038            }
   1039            if ((Response & CARD_POWER_UP_BUSY) == CARD_POWER_UP_BUSY) {
   \                     ??_SendCMD1_3:
   \   0000009C   00009DE5           LDR      R0,[SP, #+0]
   \   000000A0   800410E3           TST      R0,#0x80000000
   1040              return 0;
   \   000000A4   0000A013           MOVNE    R0,#+0
   1041            } else {
   1042              return SD_ERROR_MCI;
   \   000000A8   0100A003           MOVEQ    R0,#+1
   \                     ??_SendCMD1_4:
   \   000000AC   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   000000B0   7080BDE8           POP      {R4-R6,PC}       ;; return
   1043            }
   1044          }
   1045          
   1046          /*********************************************************************
   1047          *
   1048          *       _SendCMD2
   1049          *
   1050          *  Function description:
   1051          *    Asks to all cards to send the CID numbers.
   1052          *
   1053          *  Parameters:
   1054          *    pInst    - Pointer to a SD card driver instance.
   1055          *    pCID       - Pointer to a buffer for storing the CID
   1056          *
   1057          *  Return value:
   1058          *     Returns 0 if successful
   1059          *     Otherwise returns an code describing the Error.
   1060          *
   1061          */
   1062          static U8 _SendCMD2(DRIVER_INST * pInst, U32 * pCid) {
   1063            MCI_CMD *pCommand = &(pInst->Command);
   1064          
   1065            ZEROFILL(pCommand, sizeof(MCI_CMD));
   1066            //
   1067            // Fill command information
   1068            //
   1069            pCommand->Cmd          = SD_CMD_ALL_SEND_CID;
   1070            pCommand->ResponseSize = 4;
   1071            pCommand->pResp        = pCid;
   1072            //
   1073            // Set SD command state
   1074            //
   1075            pInst->State        = SD_STATE_STBY;
   1076            // Send the command
   1077                return _SendCommand(pInst);
   1078          }
   1079          
   1080          /*********************************************************************
   1081          *
   1082          *       _SendCMD3
   1083          *
   1084          *  Function description:
   1085          *    Asks The card to publish a new relative address.
   1086          *
   1087          *  Parameters:
   1088          *    pInst    - Pointer to a SD card driver instance.
   1089          *
   1090          *  Return value:
   1091          *     Returns 0 if successful
   1092          *     Otherwise returns an code describing the Error.
   1093          *
   1094          */

   \                                 In section .text, align 4, keep-with-next
   1095          static U8 _SendCMD3(DRIVER_INST * pInst) {
   \                     _SendCMD3:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1096            MCI_CMD *pCommand = &(pInst->Command);
   \   00000008   1C5084E2           ADD      R5,R4,#+28
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
   1097            U32 CardAddress;
   1098            U8 Error;
   1099          
   1100            ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   00000010   2410A0E3           MOV      R1,#+36
   \   00000014   0500A0E1           MOV      R0,R5
   \   00000018   ........           BL       __aeabi_memclr4
   1101            //
   1102            // Fill command information
   1103            //
   1104            pCommand->Cmd = SD_CMD_SET_RELATIVE_ADDR;
   \   0000001C   4300A0E3           MOV      R0,#+67
   \   00000020   400D80E3           ORR      R0,R0,#0x1000
   \   00000024   000085E5           STR      R0,[R5, #+0]
   1105            // Assign relative address to MMC card
   1106            if (pInst->CardType == CARD_MMC) {
   \   00000028   4600D4E5           LDRB     R0,[R4, #+70]
   1107              pCommand->Arg = (0x1 << 16);
   1108            }
   1109            pCommand->ResponseSize = 1;
   \   0000002C   0160A0E3           MOV      R6,#+1
   \   00000030   030050E3           CMP      R0,#+3
   \   00000034   400BA003           MOVEQ    R0,#+65536
   \   00000038   04008505           STREQ    R0,[R5, #+4]
   \   0000003C   0E60C5E5           STRB     R6,[R5, #+14]
   1110            pCommand->pResp = &CardAddress;
   \   00000040   18D085E5           STR      SP,[R5, #+24]
   1111            //
   1112            // Set SD command state
   1113            //
   1114            pInst->State = SD_STATE_STBY;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   4500C4E5           STRB     R0,[R4, #+69]
   1115            //
   1116            // Send command
   1117            //
   1118            Error = _SendCommand(pInst);
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       __SendCommand
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0100A013           MOVNE    R0,#+1
   \   0000005C   1500001A           BNE      ??_SendCMD3_0
   \   00000060   000095E5           LDR      R0,[R5, #+0]
   \   00000064   4C10A0E3           MOV      R1,#+76
   \   00000068   841B81E3           ORR      R1,R1,#0x21000
   \   0000006C   010050E1           CMP      R0,R1
   \   00000070   0700001A           BNE      ??_SendCMD3_1
   \                     ??_SendCMD3_2:
   \   00000074   180094E5           LDR      R0,[R4, #+24]
   \   00000078   006080E5           STR      R6,[R0, #+0]
   \   0000007C   401090E5           LDR      R1,[R0, #+64]
   \   00000080   301001E2           AND      R1,R1,#0x30
   \   00000084   200051E3           CMP      R1,#+32
   \   00000088   F9FFFF1A           BNE      ??_SendCMD3_2
   \   0000008C   0210A0E3           MOV      R1,#+2
   \   00000090   001080E5           STR      R1,[R0, #+0]
   \                     ??_SendCMD3_1:
   \   00000094   1000D5E5           LDRB     R0,[R5, #+16]
   1119            if (Error) {
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   0500001A           BNE      ??_SendCMD3_0
   1120              return Error;
   1121            }
   1122            // Save card address in driver
   1123            if (pInst->CardType != CARD_MMC) {
   \   000000A0   4600D4E5           LDRB     R0,[R4, #+70]
   \   000000A4   030050E3           CMP      R0,#+3
   1124              pInst->CardAddress = (U16)((CardAddress >> 16) & 0xFFFF);
   \   000000A8   00009D15           LDRNE    R0,[SP, #+0]
   \   000000AC   2068A011           LSRNE    R6,R0,#+16
   1125            } else {
   1126              // Default MMC RCA is 0x0001
   1127              pInst->CardAddress = 1;
   \   000000B0   B064C4E1           STRH     R6,[R4, #+64]
   1128            }
   1129            return 0;
   \   000000B4   0000A0E3           MOV      R0,#+0
   \                     ??_SendCMD3_0:
   \   000000B8   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   000000BC   7080BDE8           POP      {R4-R6,PC}       ;; return
   1130          }
   1131          
   1132          /*********************************************************************
   1133          *
   1134          *       _SendCMD7
   1135          *
   1136          *  Function description:
   1137          *    Toggles a card between the stand-by and the transfer states or between the
   1138          *    programming and disconnects states.
   1139          *
   1140          *  Parameters:
   1141          *    pInst    - Pointer to a SD card driver instance.
   1142          *    Rca        - Relative card address, that was previously set during initialization
   1143          *
   1144          *  Return value:
   1145          *     Returns 0 if successful
   1146          *     Otherwise returns an code describing the Error.
   1147          *
   1148          */
   1149          static U8 _SendCMD7(DRIVER_INST * pInst, U16 Rca) {
   1150            MCI_CMD *pCommand = &(pInst->Command);
   1151          
   1152            ZEROFILL(pCommand, sizeof(MCI_CMD));
   1153            //
   1154            // Fill command information
   1155            //
   1156            pCommand->Cmd = SD_CMD_SEL_DESEL_CARD;
   1157            pCommand->Arg = Rca << 16;
   1158            //
   1159            // Set SD command state
   1160            //
   1161            pInst->State = SD_STATE_STBY;
   1162            //
   1163            // Send command
   1164            //
   1165            return _SendCommand(pInst);
   1166          }
   1167          
   1168          /*********************************************************************
   1169          *
   1170          *       _SendCMD8
   1171          *
   1172          *  Function description:
   1173          *    Voltage check.
   1174          *
   1175          *  Parameters:
   1176          *    pInst       - Pointer to a SD card driver instance.
   1177          *    SupplyVoltage - Supply voltage supported by SD/MMC HOST
   1178          *
   1179          *  Return value:
   1180          *     Returns 0 if successful
   1181          *     Otherwise returns an code describing the Error.
   1182          *
   1183          */

   \                                 In section .text, align 4, keep-with-next
   1184          static U8 _SendCMD8(DRIVER_INST * pInst, U8 SupplyVoltage) {
   \                     _SendCMD8:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0160A0E1           MOV      R6,R1
   1185            MCI_CMD *pCommand = &(pInst->Command);
   \   0000000C   1C5084E2           ADD      R5,R4,#+28
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   1186            U32 Response;
   1187            U8 Error;
   1188          
   1189            ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   00000014   2410A0E3           MOV      R1,#+36
   \   00000018   0500A0E1           MOV      R0,R5
   \   0000001C   ........           BL       __aeabi_memclr4
   1190            //
   1191            // Fill command information
   1192            //
   1193            pCommand->Cmd             = SD_CMD_SEND_IF_COND;
   \   00000020   4800A0E3           MOV      R0,#+72
   \   00000024   400D80E3           ORR      R0,R0,#0x1000
   \   00000028   000085E5           STR      R0,[R5, #+0]
   1194            pCommand->Arg             = (SupplyVoltage << 8) | (0xAA);
   \   0000002C   AA00A0E3           MOV      R0,#+170
   \   00000030   066480E1           ORR      R6,R0,R6, LSL #+8
   \   00000034   046085E5           STR      R6,[R5, #+4]
   1195            pCommand->ResponseSize    = 1;
   \   00000038   0170A0E3           MOV      R7,#+1
   \   0000003C   0E70C5E5           STRB     R7,[R5, #+14]
   1196            pCommand->pResp           = &Response;
   \   00000040   18D085E5           STR      SP,[R5, #+24]
   1197            //
   1198            // Set SD command state
   1199            //
   1200            pInst->State = SD_STATE_STBY;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   4500C4E5           STRB     R0,[R4, #+69]
   1201            //
   1202            // Send command
   1203            //
   1204            Error = _SendCommand(pInst);
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       __SendCommand
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   1500001A           BNE      ??_SendCMD8_0
   \   0000005C   000095E5           LDR      R0,[R5, #+0]
   \   00000060   4C10A0E3           MOV      R1,#+76
   \   00000064   841B81E3           ORR      R1,R1,#0x21000
   \   00000068   010050E1           CMP      R0,R1
   \   0000006C   0700001A           BNE      ??_SendCMD8_1
   \                     ??_SendCMD8_2:
   \   00000070   180094E5           LDR      R0,[R4, #+24]
   \   00000074   007080E5           STR      R7,[R0, #+0]
   \   00000078   401090E5           LDR      R1,[R0, #+64]
   \   0000007C   301001E2           AND      R1,R1,#0x30
   \   00000080   200051E3           CMP      R1,#+32
   \   00000084   F9FFFF1A           BNE      ??_SendCMD8_2
   \   00000088   0210A0E3           MOV      R1,#+2
   \   0000008C   001080E5           STR      R1,[R0, #+0]
   \                     ??_SendCMD8_1:
   \   00000090   1000D5E5           LDRB     R0,[R5, #+16]
   1205            // Check result
   1206            if (Error == MCI_STATUS_NORESPONSE) {
   \   00000094   030050E3           CMP      R0,#+3
   1207              return SD_ERROR_NORESPONSE;
   \   00000098   0200A003           MOVEQ    R0,#+2
   \   0000009C   0500000A           BEQ      ??_SendCMD8_3
   1208            } else if (!Error && (Response == (U32)((SupplyVoltage << 8) | 0xAA))) {
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   00009D05           LDREQ    R0,[SP, #+0]
   \   000000A8   06005001           CMPEQ    R0,R6
   1209              return 0;
   \   000000AC   0000A003           MOVEQ    R0,#+0
   \   000000B0   0000000A           BEQ      ??_SendCMD8_3
   1210            } else {
   1211              return SD_ERROR_MCI;
   \                     ??_SendCMD8_0:
   \   000000B4   0100A0E3           MOV      R0,#+1
   \                     ??_SendCMD8_3:
   \   000000B8   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000BC   F080BDE8           POP      {R4-R7,PC}       ;; return
   1212            }
   1213          }
   1214          
   1215          /*********************************************************************
   1216          *
   1217          *       _SendCMD9
   1218          *
   1219          *  Function description:
   1220          *    Addressed card sends its card specific data.
   1221          *
   1222          *  Parameters:
   1223          *    pInst    - Pointer to a SD card driver instance.
   1224          *
   1225          *  Return value:
   1226          *     Returns 0 if successful
   1227          *     Otherwise returns an code describing the Error.
   1228          *
   1229          */

   \                                 In section .text, align 4, keep-with-next
   1230          static U8 _SendCMD9(DRIVER_INST * pInst) {
   \                     _SendCMD9:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1231            MCI_CMD *pCommand = &(pInst->Command);
   \   00000008   1C5084E2           ADD      R5,R4,#+28
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   1232          
   1233            ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   00000010   2410A0E3           MOV      R1,#+36
   \   00000014   0500A0E1           MOV      R0,R5
   \   00000018   ........           BL       __aeabi_memclr4
   1234            //
   1235            // Fill command information
   1236            //
   1237            pCommand->Cmd = SD_CMD_SEND_CSD;
   \   0000001C   8900A0E3           MOV      R0,#+137
   \   00000020   400D80E3           ORR      R0,R0,#0x1000
   \   00000024   000085E5           STR      R0,[R5, #+0]
   1238            pCommand->Arg = pInst->CardAddress << 16;
   \   00000028   B004D4E1           LDRH     R0,[R4, #+64]
   \   0000002C   0008A0E1           LSL      R0,R0,#+16
   \   00000030   040085E5           STR      R0,[R5, #+4]
   1239            pCommand->ResponseSize = 4;
   \   00000034   0400A0E3           MOV      R0,#+4
   \   00000038   0E00C5E5           STRB     R0,[R5, #+14]
   1240            pCommand->pResp = pInst->csd;
   \   0000003C   184085E5           STR      R4,[R5, #+24]
   1241            //
   1242            // Set SD command state
   1243            //
   1244            pInst->State = SD_STATE_STBY;
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   4500C4E5           STRB     R0,[R4, #+69]
   1245            //
   1246            // Send command
   1247            //
   1248            return _SendCommand(pInst);
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       __SendCommand
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0100A013           MOVNE    R0,#+1
   \   00000058   0E00001A           BNE      ??_SendCMD9_0
   \   0000005C   000095E5           LDR      R0,[R5, #+0]
   \   00000060   4C10A0E3           MOV      R1,#+76
   \   00000064   841B81E3           ORR      R1,R1,#0x21000
   \   00000068   010050E1           CMP      R0,R1
   \   0000006C   0800001A           BNE      ??_SendCMD9_1
   \                     ??_SendCMD9_2:
   \   00000070   180094E5           LDR      R0,[R4, #+24]
   \   00000074   0110A0E3           MOV      R1,#+1
   \   00000078   001080E5           STR      R1,[R0, #+0]
   \   0000007C   401090E5           LDR      R1,[R0, #+64]
   \   00000080   301001E2           AND      R1,R1,#0x30
   \   00000084   200051E3           CMP      R1,#+32
   \   00000088   F8FFFF1A           BNE      ??_SendCMD9_2
   \   0000008C   0210A0E3           MOV      R1,#+2
   \   00000090   001080E5           STR      R1,[R0, #+0]
   \                     ??_SendCMD9_1:
   \   00000094   1000D5E5           LDRB     R0,[R5, #+16]
   \                     ??_SendCMD9_0:
   \   00000098   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000009C   3080BDE8           POP      {R4,R5,PC}       ;; return
   1249          }
   1250          
   1251          /*********************************************************************
   1252          *
   1253          *       _SendCMD12
   1254          *
   1255          *  Function description:
   1256          *    Forces the card to stop transmission.
   1257          *
   1258          *  Parameters:
   1259          *    pInst    - Pointer to a SD card driver instance.
   1260          *
   1261          *  Return value:
   1262          *     Returns 0 if successful
   1263          *     Otherwise returns an code describing the Error.
   1264          *
   1265          */
   1266          static U8 _SendCMD12(DRIVER_INST * pInst) {
   1267            MCI_CMD *pCommand = &(pInst->Command);
   1268          
   1269            ZEROFILL(pCommand, sizeof(MCI_CMD));
   1270            //
   1271            // Fill command information
   1272            //
   1273            pCommand->Cmd      = SD_CMD_STOP_TRANSMISSION;
   1274            pCommand->ConTrans = MCI_NEW_TRANSFER;
   1275            //
   1276            // Set SD command state
   1277            //
   1278            pInst->State         = SD_STATE_STBY;
   1279            //
   1280            // Send command
   1281            //
   1282            return _SendCommand(pInst);
   1283          }
   1284          
   1285          /*********************************************************************
   1286          *
   1287          *       _SendCMD13
   1288          *
   1289          *  Function description:
   1290          *    Addressed card sends its Status register.
   1291          *
   1292          *  Parameters:
   1293          *    pInst    - Pointer to a SD card driver instance.
   1294          *    pStatus    - Pointer to a Status variable.
   1295          *
   1296          *  Return value:
   1297          *     Returns 0 if successful
   1298          *     Otherwise returns an code describing the Error.
   1299          *
   1300          */

   \                                 In section .text, align 4, keep-with-next
   1301          static U8 _SendCMD13(DRIVER_INST * pInst, U32 *pStatus) {
   \                     _SendCMD13:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0170A0E1           MOV      R7,R1
   1302            MCI_CMD *pCommand = &(pInst->Command);
   \   0000000C   1C5084E2           ADD      R5,R4,#+28
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   1303          
   1304            ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   00000014   2410A0E3           MOV      R1,#+36
   \   00000018   0500A0E1           MOV      R0,R5
   \   0000001C   ........           BL       __aeabi_memclr4
   1305            //
   1306            // Fill command information
   1307            //
   1308            pCommand->Cmd = SD_CMD_SEND_STATUS;
   \   00000020   4D00A0E3           MOV      R0,#+77
   \   00000024   400D80E3           ORR      R0,R0,#0x1000
   \   00000028   000085E5           STR      R0,[R5, #+0]
   1309            pCommand->Arg = pInst->CardAddress << 16;
   \   0000002C   B004D4E1           LDRH     R0,[R4, #+64]
   1310            pCommand->ResponseSize = 1;
   \   00000030   0160A0E3           MOV      R6,#+1
   \   00000034   0008A0E1           LSL      R0,R0,#+16
   \   00000038   040085E5           STR      R0,[R5, #+4]
   \   0000003C   0E60C5E5           STRB     R6,[R5, #+14]
   1311            pCommand->pResp = pStatus;
   \   00000040   187085E5           STR      R7,[R5, #+24]
   1312            //
   1313            // Set SD command state
   1314            //
   1315            pInst->State = SD_STATE_STBY;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   4500C4E5           STRB     R0,[R4, #+69]
   1316            //
   1317            // Send command
   1318            //
   1319            return _SendCommand(pInst);
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       __SendCommand
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0D00001A           BNE      ??_SendCMD13_0
   \   0000005C   000095E5           LDR      R0,[R5, #+0]
   \   00000060   4C10A0E3           MOV      R1,#+76
   \   00000064   841B81E3           ORR      R1,R1,#0x21000
   \   00000068   010050E1           CMP      R0,R1
   \   0000006C   0700001A           BNE      ??_SendCMD13_1
   \                     ??_SendCMD13_2:
   \   00000070   180094E5           LDR      R0,[R4, #+24]
   \   00000074   006080E5           STR      R6,[R0, #+0]
   \   00000078   401090E5           LDR      R1,[R0, #+64]
   \   0000007C   301001E2           AND      R1,R1,#0x30
   \   00000080   200051E3           CMP      R1,#+32
   \   00000084   F9FFFF1A           BNE      ??_SendCMD13_2
   \   00000088   0210A0E3           MOV      R1,#+2
   \   0000008C   001080E5           STR      R1,[R0, #+0]
   \                     ??_SendCMD13_1:
   \   00000090   1060D5E5           LDRB     R6,[R5, #+16]
   \                     ??_SendCMD13_0:
   \   00000094   0600A0E1           MOV      R0,R6
   \   00000098   04D08DE2           ADD      SP,SP,#+4
   \   0000009C   F080BDE8           POP      {R4-R7,PC}       ;; return
   1320          }
   1321          
   1322          /*********************************************************************
   1323          *
   1324          *       _SendCMD16
   1325          *
   1326          *  Function description:
   1327          *    In the case of a Standard Capacity SD Memory Card, this command sets the
   1328          *    block length/sector size (in bytes) for all following block commands
   1329          *    (read, write, lock).
   1330          *    Default block length is fixed to 512 Bytes.
   1331          *
   1332          *    Set length is valid for memory access commands only if partial block read
   1333          *    operation are allowed in CSD.
   1334          *
   1335          *    In the case of a High Capacity SD Memory Card, block length set by CMD16
   1336          *    command does not affect the memory read and write commands. Always 512
   1337          *    Bytes fixed block length is used. This command is effective for LOCK_UNLOCK command.
   1338          *    In both cases, if block length is set larger than 512Bytes, the card sets the
   1339          *    BLOCK_LEN_ERROR bit.
   1340          
   1341          *
   1342          *  Parameters:
   1343          *    pInst    - Pointer to a SD card driver instance.
   1344          *    SectorSize - Sector size in bytes.
   1345          *
   1346          *  Return value:
   1347          *     Returns 0 if successful
   1348          *     Otherwise returns an code describing the Error.
   1349          *
   1350          */
   1351          static U8 _SendCMD16(DRIVER_INST * pInst, U16 SectorSize) {
   1352            MCI_CMD *pCommand = &(pInst->Command);
   1353          
   1354            ZEROFILL(pCommand, sizeof(MCI_CMD));
   1355            //
   1356            // Fill command information
   1357            //
   1358            pCommand->Cmd = SD_CMD_SET_BLOCKLEN;
   1359            pCommand->Arg = SectorSize;
   1360            //
   1361            // Set SD command state
   1362            //
   1363            pInst->State = SD_STATE_STBY;
   1364            //
   1365            // Send command
   1366            //
   1367            return _SendCommand(pInst);
   1368          }
   1369          
   1370          /*********************************************************************
   1371          *
   1372          *       _SendCMD18
   1373          *
   1374          *  Function description:
   1375          *    Continuously transfers data blocks from card to host until interrupted by a
   1376          *    STOP_TRANSMISSION command.
   1377          *
   1378          *  Parameters:
   1379          *    pInst    - Pointer to a SD card driver instance.
   1380          *    SectorNo   - Start sector no. to transfer
   1381          *    NumSectors - Number of sector to be transferred
   1382          *    pData      - Pointer to the data buffer.
   1383          *
   1384          *  Return value:
   1385          *     Returns 0 if successful
   1386          *     Otherwise returns an code describing the Error.
   1387          *
   1388          */

   \                                 In section .text, align 4, keep-with-next
   1389          static U8 _SendCMD18(DRIVER_INST * pInst, unsigned NumSectors, U8 *pData, U32 SectorNo) {
   \                     _SendCMD18:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0160A0E1           MOV      R6,R1
   1390            MCI_CMD *pCommand = &(pInst->Command);
   \   0000000C   1C5084E2           ADD      R5,R4,#+28
   \   00000010   0270A0E1           MOV      R7,R2
   \   00000014   0380A0E1           MOV      R8,R3
   1391          
   1392            ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   00000018   2410A0E3           MOV      R1,#+36
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   ........           BL       __aeabi_memclr4
   1393            //
   1394            // Fill command information
   1395            //
   1396            pCommand->Cmd = SD_CMD_READ_MULTIPLE_BLOCK;
   \   00000024   5200A0E3           MOV      R0,#+82
   \   00000028   D10A80E3           ORR      R0,R0,#0xD1000
   \   0000002C   000085E5           STR      R0,[R5, #+0]
   1397            pCommand->Arg = SectorNo;
   \   00000030   048085E5           STR      R8,[R5, #+4]
   1398            pCommand->SectorSize = SECTOR_SIZE;
   \   00000034   800FA0E3           MOV      R0,#+512
   \   00000038   B800C5E1           STRH     R0,[R5, #+8]
   1399            pCommand->NumSectors = NumSectors;
   \   0000003C   BA60C5E1           STRH     R6,[R5, #+10]
   1400            pCommand->pData = pData;
   \   00000040   147085E5           STR      R7,[R5, #+20]
   1401            pCommand->IsRead = 1;
   \   00000044   0160A0E3           MOV      R6,#+1
   \   00000048   0D60C5E5           STRB     R6,[R5, #+13]
   1402            pCommand->ConTrans = MCI_NEW_TRANSFER;
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   0C00C5E5           STRB     R0,[R5, #+12]
   1403            //
   1404            // Set SD command state
   1405            //
   1406            pInst->State = SD_STATE_DATA;
   \   00000054   4560C4E5           STRB     R6,[R4, #+69]
   1407            //
   1408            // Send command
   1409            //
   1410            return _SendCommand(pInst);
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       __SendCommand
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0D00001A           BNE      ??_SendCMD18_0
   \   00000068   000095E5           LDR      R0,[R5, #+0]
   \   0000006C   4C10A0E3           MOV      R1,#+76
   \   00000070   841B81E3           ORR      R1,R1,#0x21000
   \   00000074   010050E1           CMP      R0,R1
   \   00000078   0700001A           BNE      ??_SendCMD18_1
   \                     ??_SendCMD18_2:
   \   0000007C   180094E5           LDR      R0,[R4, #+24]
   \   00000080   006080E5           STR      R6,[R0, #+0]
   \   00000084   401090E5           LDR      R1,[R0, #+64]
   \   00000088   301001E2           AND      R1,R1,#0x30
   \   0000008C   200051E3           CMP      R1,#+32
   \   00000090   F9FFFF1A           BNE      ??_SendCMD18_2
   \   00000094   0210A0E3           MOV      R1,#+2
   \   00000098   001080E5           STR      R1,[R0, #+0]
   \                     ??_SendCMD18_1:
   \   0000009C   1060D5E5           LDRB     R6,[R5, #+16]
   \                     ??_SendCMD18_0:
   \   000000A0   0600A0E1           MOV      R0,R6
   \   000000A4   F081BDE8           POP      {R4-R8,PC}       ;; return
   1411          }
   1412          
   1413          /*********************************************************************
   1414          *
   1415          *       _SendCMD25
   1416          *
   1417          *  Function description:
   1418          *    Write block command
   1419          *
   1420          *  Parameters:
   1421          *    pInst    - Pointer to a SD card driver instance.
   1422          *    SectorNo   - Start sector no. to transfer
   1423          *    NumSectors - Number of sector to be transferred
   1424          *    pData      - Pointer to the data buffer.
   1425          *
   1426          *  Return value:
   1427          *     Returns 0 if successful
   1428          *     Otherwise returns an code describing the Error.
   1429          *
   1430          */

   \                                 In section .text, align 4, keep-with-next
   1431          static U8 _SendCMD25(DRIVER_INST * pInst, unsigned NumBlocks, U8 *pData, U32 SectorNo) {
   \                     _SendCMD25:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0160A0E1           MOV      R6,R1
   1432            MCI_CMD *pCommand = &(pInst->Command);
   \   0000000C   1C5084E2           ADD      R5,R4,#+28
   \   00000010   0270A0E1           MOV      R7,R2
   \   00000014   0380A0E1           MOV      R8,R3
   1433          
   1434            ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   00000018   2410A0E3           MOV      R1,#+36
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   ........           BL       __aeabi_memclr4
   1435            //
   1436            // Fill command information
   1437            //
   1438            pCommand->Cmd = SD_CMD_WRITE_MULTIPLE_BLOCK;
   \   00000024   5900A0E3           MOV      R0,#+89
   \   00000028   910A80E3           ORR      R0,R0,#0x91000
   \   0000002C   000085E5           STR      R0,[R5, #+0]
   1439            pCommand->Arg = SectorNo;
   \   00000030   048085E5           STR      R8,[R5, #+4]
   1440            pCommand->SectorSize = SECTOR_SIZE;
   \   00000034   800FA0E3           MOV      R0,#+512
   \   00000038   B800C5E1           STRH     R0,[R5, #+8]
   1441            pCommand->NumSectors = NumBlocks;
   \   0000003C   BA60C5E1           STRH     R6,[R5, #+10]
   1442            pCommand->pData = (U8 *) pData;
   \   00000040   147085E5           STR      R7,[R5, #+20]
   1443            pCommand->ConTrans = MCI_NEW_TRANSFER;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   0C00C5E5           STRB     R0,[R5, #+12]
   1444            //
   1445            // Set SD command state
   1446            //
   1447            pInst->State = SD_STATE_RCV;
   \   0000004C   0260A0E3           MOV      R6,#+2
   \   00000050   4560C4E5           STRB     R6,[R4, #+69]
   1448            //
   1449            // Send command
   1450            //
   1451            return _SendCommand(pInst);
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       __SendCommand
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0100000A           BEQ      ??_SendCMD25_0
   \   00000064   0100A0E3           MOV      R0,#+1
   \   00000068   F081BDE8           POP      {R4-R8,PC}
   \                     ??_SendCMD25_0:
   \   0000006C   000095E5           LDR      R0,[R5, #+0]
   \   00000070   4C10A0E3           MOV      R1,#+76
   \   00000074   841B81E3           ORR      R1,R1,#0x21000
   \   00000078   010050E1           CMP      R0,R1
   \   0000007C   0700001A           BNE      ??_SendCMD25_1
   \                     ??_SendCMD25_2:
   \   00000080   180094E5           LDR      R0,[R4, #+24]
   \   00000084   0110A0E3           MOV      R1,#+1
   \   00000088   001080E5           STR      R1,[R0, #+0]
   \   0000008C   401090E5           LDR      R1,[R0, #+64]
   \   00000090   301001E2           AND      R1,R1,#0x30
   \   00000094   200051E3           CMP      R1,#+32
   \   00000098   F8FFFF1A           BNE      ??_SendCMD25_2
   \   0000009C   006080E5           STR      R6,[R0, #+0]
   \                     ??_SendCMD25_1:
   \   000000A0   1000D5E5           LDRB     R0,[R5, #+16]
   \   000000A4   F081BDE8           POP      {R4-R8,PC}       ;; return
   1452          }
   1453          
   1454          /*********************************************************************
   1455          *
   1456          *       _SendCMD55
   1457          *
   1458          *  Function description:
   1459          *    Sends the APP command to indicate that an application command is sent.
   1460          *
   1461          *  Parameters:
   1462          *    pInst    - Pointer to a SD card driver instance.
   1463          *
   1464          *  Return value:
   1465          *     Returns 0 if successful
   1466          *     Otherwise returns an code describing the Error.
   1467          *
   1468          */
   1469          static U8 _SendCMD55(DRIVER_INST * pInst) {
   1470            MCI_CMD *pCommand = &(pInst->Command);
   1471          
   1472            ZEROFILL(pCommand, sizeof(MCI_CMD));
   1473            //
   1474            // Fill command information
   1475            //
   1476            pCommand->Cmd = SD_CMD_APP;
   1477            pCommand->Arg = (pInst->CardAddress << 16);
   1478            //
   1479            // Set SD command state
   1480            //
   1481            pInst->State = SD_STATE_STBY;
   1482            //
   1483            // Send command
   1484            //
   1485            return _SendCommand(pInst);
   1486          }
   1487          
   1488          /*********************************************************************
   1489          *
   1490          *       _SendACMD6
   1491          *
   1492          *  Function description:
   1493          *    Defines the data bus width (00=1bit or 10=4 bits bus) to be used for data transfer.
   1494          *    The allowed data bus widths are given in SCR register.
   1495          *
   1496          *  Parameters:
   1497          *    pInst    - Pointer to a SD card driver instance.
   1498          *    BusWidth   - Bus Width in Bits
   1499          *
   1500          *  Return value:
   1501          *     Returns 0 if successful
   1502          *     Otherwise returns an code describing the Error.
   1503          *
   1504          */

   \                                 In section .text, align 4, keep-with-next
   1505          static U8 _SendACMD6(DRIVER_INST * pInst, U8 BusWidth) {
   \                     _SendACMD6:
   \   00000000   70472DE9           PUSH     {R4-R6,R8-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1506            MCI_CMD *pCommand = &(pInst->Command);
   \   0000000C   1C6084E2           ADD      R6,R4,#+28
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   1507            U8 Error;
   1508          
   1509            //
   1510            // Send ACMD
   1511            //
   1512            Error = _SendCMD55(pInst);
   \   00000014   2410A0E3           MOV      R1,#+36
   \   00000018   0600A0E1           MOV      R0,R6
   \   0000001C   ........           BL       __aeabi_memclr4
   \   00000020   7700A0E3           MOV      R0,#+119
   \   00000024   400D80E3           ORR      R0,R0,#0x1000
   \   00000028   000086E5           STR      R0,[R6, #+0]
   \   0000002C   B004D4E1           LDRH     R0,[R4, #+64]
   \   00000030   0080A0E3           MOV      R8,#+0
   \   00000034   0008A0E1           LSL      R0,R0,#+16
   \   00000038   040086E5           STR      R0,[R6, #+4]
   \   0000003C   4580C4E5           STRB     R8,[R4, #+69]
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       __SendCommand
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0100000A           BEQ      ??_SendACMD6_0
   \   00000050   0100A0E3           MOV      R0,#+1
   \   00000054   2E0000EA           B        ??_SendACMD6_1
   \                     ??_SendACMD6_0:
   \   00000058   4C90A0E3           MOV      R9,#+76
   \   0000005C   000096E5           LDR      R0,[R6, #+0]
   \   00000060   849B89E3           ORR      R9,R9,#0x21000
   \   00000064   090050E1           CMP      R0,R9
   \   00000068   0800001A           BNE      ??_SendACMD6_2
   \                     ??_SendACMD6_3:
   \   0000006C   180094E5           LDR      R0,[R4, #+24]
   \   00000070   0110A0E3           MOV      R1,#+1
   \   00000074   001080E5           STR      R1,[R0, #+0]
   \   00000078   401090E5           LDR      R1,[R0, #+64]
   \   0000007C   301001E2           AND      R1,R1,#0x30
   \   00000080   200051E3           CMP      R1,#+32
   \   00000084   F8FFFF1A           BNE      ??_SendACMD6_3
   \   00000088   0210A0E3           MOV      R1,#+2
   \   0000008C   001080E5           STR      R1,[R0, #+0]
   \                     ??_SendACMD6_2:
   \   00000090   1000D6E5           LDRB     R0,[R6, #+16]
   1513            if (Error) {
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   1D00001A           BNE      ??_SendACMD6_1
   1514              return Error;
   1515            }
   1516            ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   0000009C   2410A0E3           MOV      R1,#+36
   \   000000A0   0600A0E1           MOV      R0,R6
   \   000000A4   ........           BL       __aeabi_memclr4
   1517            //
   1518            // Fill command information
   1519            //
   1520            pCommand->Cmd      = SD_CMD_APP_SET_BUS_WIDTH;
   \   000000A8   4600A0E3           MOV      R0,#+70
   \   000000AC   400D80E3           ORR      R0,R0,#0x1000
   \   000000B0   000086E5           STR      R0,[R6, #+0]
   1521            pCommand->IsAppCmd = 1;
   \   000000B4   01A0A0E3           MOV      R10,#+1
   1522            if (BusWidth == 4) {
   \   000000B8   040055E3           CMP      R5,#+4
   \   000000BC   0FA0C6E5           STRB     R10,[R6, #+15]
   1523              pCommand->Arg = SD_SCR_BUS_WIDTH_4BITS;
   \   000000C0   0200A003           MOVEQ    R0,#+2
   1524            } else {
   1525              pCommand->Arg = SD_SCR_BUS_WIDTH_1BIT;
   \   000000C4   0100A013           MOVNE    R0,#+1
   \   000000C8   040086E5           STR      R0,[R6, #+4]
   1526            }
   1527            //
   1528            // Set SD command state
   1529            //
   1530            pInst->State = SD_STATE_STBY;
   \   000000CC   4580C4E5           STRB     R8,[R4, #+69]
   1531            //
   1532            // Send command
   1533            //
   1534            return _SendCommand(pInst);
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           BL       __SendCommand
   \   000000D8   000050E3           CMP      R0,#+0
   \   000000DC   0B00001A           BNE      ??_SendACMD6_4
   \   000000E0   000096E5           LDR      R0,[R6, #+0]
   \   000000E4   090050E1           CMP      R0,R9
   \   000000E8   0700001A           BNE      ??_SendACMD6_5
   \                     ??_SendACMD6_6:
   \   000000EC   180094E5           LDR      R0,[R4, #+24]
   \   000000F0   00A080E5           STR      R10,[R0, #+0]
   \   000000F4   401090E5           LDR      R1,[R0, #+64]
   \   000000F8   301001E2           AND      R1,R1,#0x30
   \   000000FC   200051E3           CMP      R1,#+32
   \   00000100   F9FFFF1A           BNE      ??_SendACMD6_6
   \   00000104   0210A0E3           MOV      R1,#+2
   \   00000108   001080E5           STR      R1,[R0, #+0]
   \                     ??_SendACMD6_5:
   \   0000010C   10A0D6E5           LDRB     R10,[R6, #+16]
   \                     ??_SendACMD6_4:
   \   00000110   0A00A0E1           MOV      R0,R10
   \                     ??_SendACMD6_1:
   \   00000114   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000118   7087BDE8           POP      {R4-R6,R8-R10,PC}  ;; return
   1535          }
   1536          
   1537          /*********************************************************************
   1538          *
   1539          *       _SendACMD41
   1540          *
   1541          *  Function description:
   1542          *    Asks to all cards to send their operations conditions.
   1543          *
   1544          *  Parameters:
   1545          *    pInst    - Pointer to a SD card driver instance.
   1546          *    hcs        - Shall be set to 1 if Host support High capacity.
   1547          *    pCCS       - Set the pointed flag to 1 if hcs != 0 and SD OCR CCS flag is set.
   1548          *
   1549          *  Return value:
   1550          *     Returns 0 if successful
   1551          *     Otherwise returns an code describing the Error.
   1552          *
   1553          */

   \                                 In section .text, align 4, keep-with-next
   1554          static U8 _SendACMD41(DRIVER_INST * pInst, U8 hcs, U8 *pCCS) {
   \                     _SendACMD41:
   \   00000000   B6472DE9           PUSH     {R1,R2,R4,R5,R7-R10,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   1555            MCI_CMD *pCommand = &(pInst->Command);
   \   00000008   4C90A0E3           MOV      R9,#+76
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   1C4085E2           ADD      R4,R5,#+28
   \   00000014   0270A0E3           MOV      R7,#+2
   \   00000018   0180A0E3           MOV      R8,#+1
   \   0000001C   849B89E3           ORR      R9,R9,#0x21000
   1556            U8 Error;
   1557            U32 Response;
   1558          
   1559            do {
   1560              //
   1561              // Delay
   1562              //
   1563              DELAY(2000);
   \                     ??_SendACMD41_0:
   \   00000020   7D1EA0E3           MOV      R1,#+2000
   \   00000024   04108DE5           STR      R1,[SP, #+4]
   \                     ??_SendACMD41_1:
   \   00000028   04009DE5           LDR      R0,[SP, #+4]
   \   0000002C   010050E2           SUBS     R0,R0,#+1
   \   00000030   04008DE5           STR      R0,[SP, #+4]
   \   00000034   FBFFFF1A           BNE      ??_SendACMD41_1
   1564              Error = _SendCMD55(pInst);
   \   00000038   2410A0E3           MOV      R1,#+36
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       __aeabi_memclr4
   \   00000044   7700A0E3           MOV      R0,#+119
   \   00000048   400D80E3           ORR      R0,R0,#0x1000
   \   0000004C   000084E5           STR      R0,[R4, #+0]
   \   00000050   B004D5E1           LDRH     R0,[R5, #+64]
   \   00000054   00A0A0E3           MOV      R10,#+0
   \   00000058   0008A0E1           LSL      R0,R0,#+16
   \   0000005C   040084E5           STR      R0,[R4, #+4]
   \   00000060   45A0C5E5           STRB     R10,[R5, #+69]
   \   00000064   0500A0E1           MOV      R0,R5
   \   00000068   ........           BL       __SendCommand
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   1E00001A           BNE      ??_SendACMD41_2
   \   00000074   000094E5           LDR      R0,[R4, #+0]
   \   00000078   090050E1           CMP      R0,R9
   \   0000007C   0600001A           BNE      ??_SendACMD41_3
   \                     ??_SendACMD41_4:
   \   00000080   180095E5           LDR      R0,[R5, #+24]
   \   00000084   008080E5           STR      R8,[R0, #+0]
   \   00000088   401090E5           LDR      R1,[R0, #+64]
   \   0000008C   301001E2           AND      R1,R1,#0x30
   \   00000090   200051E3           CMP      R1,#+32
   \   00000094   F9FFFF1A           BNE      ??_SendACMD41_4
   \   00000098   007080E5           STR      R7,[R0, #+0]
   \                     ??_SendACMD41_3:
   \   0000009C   1000D4E5           LDRB     R0,[R4, #+16]
   1565              if (Error) {
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   2900001A           BNE      ??_SendACMD41_5
   1566                return Error;
   1567              }
   1568              ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   000000A8   2410A0E3           MOV      R1,#+36
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   ........           BL       __aeabi_memclr4
   1569              //
   1570              // Fill command information
   1571              //
   1572              pCommand->Cmd      = SD_CMD_APP_APP_OP_COND;
   \   000000B4   6900A0E3           MOV      R0,#+105
   \   000000B8   000084E5           STR      R0,[R4, #+0]
   1573              pCommand->Arg      = MMC_HOST_VOLTAGE_RANGE;
   1574              pCommand->IsAppCmd = 1;
   \   000000BC   0F80C4E5           STRB     R8,[R4, #+15]
   1575              if (hcs) {
   \   000000C0   0C10DDE5           LDRB     R1,[SP, #+12]
   \   000000C4   7E09A0E3           MOV      R0,#+2064384
   \   000000C8   000051E3           CMP      R1,#+0
   1576                pCommand->Arg |= SD_CCS;
   \   000000CC   40048013           ORRNE    R0,R0,#0x40000000
   \   000000D0   040084E5           STR      R0,[R4, #+4]
   1577              }
   1578              pCommand->ResponseSize = 1;
   \   000000D4   0E80C4E5           STRB     R8,[R4, #+14]
   1579              pCommand->pResp = &Response;
   \   000000D8   18D084E5           STR      SP,[R4, #+24]
   1580              //
   1581              // Set SD command state
   1582              //
   1583              pInst->State = SD_STATE_STBY;
   \   000000DC   45A0C5E5           STRB     R10,[R5, #+69]
   1584              //
   1585              // Send command
   1586              //
   1587              Error = _SendCommand(pInst);
   \   000000E0   0500A0E1           MOV      R0,R5
   \   000000E4   ........           BL       __SendCommand
   \   000000E8   000050E3           CMP      R0,#+0
   \   000000EC   0100000A           BEQ      ??_SendACMD41_6
   \                     ??_SendACMD41_2:
   \   000000F0   0100A0E3           MOV      R0,#+1
   \   000000F4   150000EA           B        ??_SendACMD41_5
   \                     ??_SendACMD41_6:
   \   000000F8   000094E5           LDR      R0,[R4, #+0]
   \   000000FC   090050E1           CMP      R0,R9
   \   00000100   0600001A           BNE      ??_SendACMD41_7
   \                     ??_SendACMD41_8:
   \   00000104   180095E5           LDR      R0,[R5, #+24]
   \   00000108   008080E5           STR      R8,[R0, #+0]
   \   0000010C   401090E5           LDR      R1,[R0, #+64]
   \   00000110   301001E2           AND      R1,R1,#0x30
   \   00000114   200051E3           CMP      R1,#+32
   \   00000118   F9FFFF1A           BNE      ??_SendACMD41_8
   \   0000011C   007080E5           STR      R7,[R0, #+0]
   \                     ??_SendACMD41_7:
   \   00000120   1000D4E5           LDRB     R0,[R4, #+16]
   1588              if (Error) {
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   0800001A           BNE      ??_SendACMD41_5
   1589                return Error;
   1590              }
   1591              *pCCS  = ((Response & SD_CCS) != 0);
   \   0000012C   00009DE5           LDR      R0,[SP, #+0]
   \   00000130   10109DE5           LDR      R1,[SP, #+16]
   \   00000134   200FA0E1           LSR      R0,R0,#+30
   \   00000138   010000E2           AND      R0,R0,#0x1
   \   0000013C   0000C1E5           STRB     R0,[R1, #+0]
   1592            } while ((Response & CARD_POWER_UP_BUSY) != CARD_POWER_UP_BUSY);
   \   00000140   00009DE5           LDR      R0,[SP, #+0]
   \   00000144   800410E3           TST      R0,#0x80000000
   \   00000148   B4FFFF0A           BEQ      ??_SendACMD41_0
   1593            return 0;
   \   0000014C   0000A0E3           MOV      R0,#+0
   \                     ??_SendACMD41_5:
   \   00000150   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000154   B087BDE8           POP      {R4,R5,R7-R10,PC}  ;; return
   1594          }
   1595          
   1596          
   1597          /*********************************************************************
   1598          *
   1599          *       _ContinuousRead
   1600          *
   1601          *  Function description:
   1602          *    Continue to transfer data blocks from host to card until interrupted by a
   1603          *    STOP_TRANSMISSION command.
   1604          *
   1605          *  Parameters:
   1606          *    pInst    - Pointer to a SD card driver instance.
   1607          *    SectorNo   - Start sector no. to transfer
   1608          *    NumSectors - Number of sector to be transferred
   1609          *    pData      - Pointer to the data buffer.
   1610          *
   1611          *  Return value:
   1612          *     Returns 0 if successful
   1613          *     Otherwise returns an code describing the Error.
   1614          *
   1615          */

   \                                 In section .text, align 4, keep-with-next
   1616          static U8 _ContinuousRead(DRIVER_INST * pInst, unsigned NumBlocks, U8 *pData, U32 SectorNo) {
   \                     _ContinuousRead:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1617            MCI_CMD *pCommand = &(pInst->Command);
   \   0000000C   1C7084E2           ADD      R7,R4,#+28
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   0260A0E1           MOV      R6,R2
   1618          
   1619            FS_USE_PARA(SectorNo);
   1620            ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   00000018   2410A0E3           MOV      R1,#+36
   \   0000001C   0700A0E1           MOV      R0,R7
   \   00000020   ........           BL       __aeabi_memclr4
   1621            //
   1622            // Fill command information
   1623            //
   1624            pCommand->SectorSize = SECTOR_SIZE;
   \   00000024   800FA0E3           MOV      R0,#+512
   \   00000028   B800C7E1           STRH     R0,[R7, #+8]
   1625            pCommand->NumSectors = NumBlocks;
   \   0000002C   BA50C7E1           STRH     R5,[R7, #+10]
   1626            pCommand->pData = pData;
   \   00000030   146087E5           STR      R6,[R7, #+20]
   1627            pCommand->IsRead = 1;
   \   00000034   0150A0E3           MOV      R5,#+1
   \   00000038   0D50C7E5           STRB     R5,[R7, #+13]
   1628            pCommand->ConTrans = MCI_CONTINUE_TRANSFER;
   \   0000003C   0C50C7E5           STRB     R5,[R7, #+12]
   1629            //
   1630            // Set SD command state
   1631            //
   1632            pInst->State = SD_STATE_DATA;
   \   00000040   4550C4E5           STRB     R5,[R4, #+69]
   1633            //
   1634            // Send command
   1635            //
   1636            return _SendCommand(pInst);
   \   00000044   1C6084E2           ADD      R6,R4,#+28
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       __SendCommand
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0D00001A           BNE      ??_ContinuousRead_0
   \   00000058   000096E5           LDR      R0,[R6, #+0]
   \   0000005C   4C10A0E3           MOV      R1,#+76
   \   00000060   841B81E3           ORR      R1,R1,#0x21000
   \   00000064   010050E1           CMP      R0,R1
   \   00000068   0700001A           BNE      ??_ContinuousRead_1
   \                     ??_ContinuousRead_2:
   \   0000006C   180094E5           LDR      R0,[R4, #+24]
   \   00000070   005080E5           STR      R5,[R0, #+0]
   \   00000074   401090E5           LDR      R1,[R0, #+64]
   \   00000078   301001E2           AND      R1,R1,#0x30
   \   0000007C   200051E3           CMP      R1,#+32
   \   00000080   F9FFFF1A           BNE      ??_ContinuousRead_2
   \   00000084   0210A0E3           MOV      R1,#+2
   \   00000088   001080E5           STR      R1,[R0, #+0]
   \                     ??_ContinuousRead_1:
   \   0000008C   1050D6E5           LDRB     R5,[R6, #+16]
   \                     ??_ContinuousRead_0:
   \   00000090   0500A0E1           MOV      R0,R5
   \   00000094   04D08DE2           ADD      SP,SP,#+4
   \   00000098   F080BDE8           POP      {R4-R7,PC}       ;; return
   1637          }
   1638          
   1639          /*********************************************************************
   1640          *
   1641          *       _ContinuousWrite
   1642          *
   1643          *  Function description:
   1644          *    Continue to transfer data blocks from host to card until interrupted by a
   1645          *    STOP_TRANSMISSION command.
   1646          *
   1647          *  Parameters:
   1648          *    pInst    - Pointer to a SD card driver instance.
   1649          *    SectorNo   - Start sector no. to transfer
   1650          *    NumSectors - Number of sector to be transferred
   1651          *    pData      - Pointer to the data buffer.
   1652          *
   1653          *  Return value:
   1654          *     Returns 0 if successful
   1655          *     Otherwise returns an code describing the Error.
   1656          *
   1657          */

   \                                 In section .text, align 4, keep-with-next
   1658          static U8 _ContinuousWrite(DRIVER_INST * pInst, unsigned NumBlocks, const U8 *pData, U32 SectorNo) {
   \                     _ContinuousWrite:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1659            MCI_CMD * pCommand = &(pInst->Command);
   \   0000000C   1C7084E2           ADD      R7,R4,#+28
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   0260A0E1           MOV      R6,R2
   1660          
   1661            FS_USE_PARA(SectorNo);
   1662            ZEROFILL(pCommand, sizeof(MCI_CMD));
   \   00000018   2410A0E3           MOV      R1,#+36
   \   0000001C   0700A0E1           MOV      R0,R7
   \   00000020   ........           BL       __aeabi_memclr4
   1663            //
   1664            // Fill command information
   1665            //
   1666            pCommand->SectorSize = SECTOR_SIZE;
   \   00000024   800FA0E3           MOV      R0,#+512
   \   00000028   B800C7E1           STRH     R0,[R7, #+8]
   1667            pCommand->NumSectors = NumBlocks;
   \   0000002C   BA50C7E1           STRH     R5,[R7, #+10]
   1668            pCommand->pData = (U8 *) pData;
   \   00000030   146087E5           STR      R6,[R7, #+20]
   1669            pCommand->ConTrans = MCI_CONTINUE_TRANSFER;
   \   00000034   0150A0E3           MOV      R5,#+1
   \   00000038   0C50C7E5           STRB     R5,[R7, #+12]
   1670            //
   1671            // Set SD command state
   1672            //
   1673            pInst->State = SD_STATE_RCV;
   \   0000003C   0260A0E3           MOV      R6,#+2
   \   00000040   4560C4E5           STRB     R6,[R4, #+69]
   1674            //
   1675            // Send command
   1676            //
   1677            return _SendCommand(pInst);
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       __SendCommand
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0C00001A           BNE      ??_ContinuousWrite_0
   \   00000054   000097E5           LDR      R0,[R7, #+0]
   \   00000058   4C10A0E3           MOV      R1,#+76
   \   0000005C   841B81E3           ORR      R1,R1,#0x21000
   \   00000060   010050E1           CMP      R0,R1
   \   00000064   0600001A           BNE      ??_ContinuousWrite_1
   \                     ??_ContinuousWrite_2:
   \   00000068   180094E5           LDR      R0,[R4, #+24]
   \   0000006C   005080E5           STR      R5,[R0, #+0]
   \   00000070   401090E5           LDR      R1,[R0, #+64]
   \   00000074   301001E2           AND      R1,R1,#0x30
   \   00000078   200051E3           CMP      R1,#+32
   \   0000007C   F9FFFF1A           BNE      ??_ContinuousWrite_2
   \   00000080   006080E5           STR      R6,[R0, #+0]
   \                     ??_ContinuousWrite_1:
   \   00000084   1050D7E5           LDRB     R5,[R7, #+16]
   \                     ??_ContinuousWrite_0:
   \   00000088   0500A0E1           MOV      R0,R5
   \   0000008C   04D08DE2           ADD      SP,SP,#+4
   \   00000090   F080BDE8           POP      {R4-R7,PC}       ;; return
   1678          }
   1679          
   1680          /*********************************************************************
   1681          *
   1682          *       _MoveToTransferState
   1683          *
   1684          *  Function description:
   1685          *    Move SD card to transfer state. The buffer size must be at
   1686          *    least 512 byte long. This function checks the SD card Status register and
   1687          *    address the card if required before sending the transfer command.
   1688          *
   1689          *  Parameters:
   1690          *    pInst    - Pointer to a SD card driver instance.
   1691          *    SectorNo   - Start sector no. to transfer
   1692          *    NumSectors - Number of sector to be transferred
   1693          *    pData      - Pointer to the data buffer.
   1694          *    IsRead     - Specifies whether a read or write operation
   1695          *
   1696          *  Return value:
   1697          *     Returns 0 if successful
   1698          *     Otherwise returns an code describing the Error.
   1699          *
   1700          */

   \                                 In section .text, align 4, keep-with-next
   1701          static U8 _MoveToTransferState(DRIVER_INST * pInst, U32 SectorNo, unsigned NumSectors, U8 *pData, U8 IsRead) {
   \                     _MoveToTransferState:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1702            U32 Status;
   1703            U8 Error;
   1704          
   1705            if((pInst->State == SD_STATE_DATA) || (pInst->State == SD_STATE_RCV)) {
   \   00000008   4500D4E5           LDRB     R0,[R4, #+69]
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   010050E3           CMP      R0,#+1
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0370A0E1           MOV      R7,R3
   \   00000020   2880DDE5           LDRB     R8,[SP, #+40]
   \   00000024   02005013           CMPNE    R0,#+2
   \   00000028   1E00001A           BNE      ??_MoveToTransferState_0
   1706              Error = _SendCMD12(pInst);
   \   0000002C   1C9084E2           ADD      R9,R4,#+28
   \   00000030   2410A0E3           MOV      R1,#+36
   \   00000034   0900A0E1           MOV      R0,R9
   \   00000038   ........           BL       __aeabi_memclr4
   \   0000003C   4CA0A0E3           MOV      R10,#+76
   \   00000040   84AB8AE3           ORR      R10,R10,#0x21000
   \   00000044   00A089E5           STR      R10,[R9, #+0]
   \   00000048   0000A0E3           MOV      R0,#+0
   \   0000004C   0C00C9E5           STRB     R0,[R9, #+12]
   \   00000050   4500C4E5           STRB     R0,[R4, #+69]
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       __SendCommand
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   5000001A           BNE      ??_MoveToTransferState_1
   \   00000064   000099E5           LDR      R0,[R9, #+0]
   \   00000068   0A0050E1           CMP      R0,R10
   \   0000006C   0800001A           BNE      ??_MoveToTransferState_2
   \                     ??_MoveToTransferState_3:
   \   00000070   180094E5           LDR      R0,[R4, #+24]
   \   00000074   0110A0E3           MOV      R1,#+1
   \   00000078   001080E5           STR      R1,[R0, #+0]
   \   0000007C   401090E5           LDR      R1,[R0, #+64]
   \   00000080   301001E2           AND      R1,R1,#0x30
   \   00000084   200051E3           CMP      R1,#+32
   \   00000088   F8FFFF1A           BNE      ??_MoveToTransferState_3
   \   0000008C   0210A0E3           MOV      R1,#+2
   \   00000090   001080E5           STR      R1,[R0, #+0]
   \                     ??_MoveToTransferState_2:
   \   00000094   1000D9E5           LDRB     R0,[R9, #+16]
   1707              if (Error) {
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   0100000A           BEQ      ??_MoveToTransferState_0
   1708                return Error;
   \                     ??_MoveToTransferState_4:
   \   000000A0   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   000000A4   F087BDE8           POP      {R4-R10,PC}      ;; return
   1709              }
   1710            }
   1711            pInst->PreSector = SectorNo + (NumSectors-1);
   \                     ??_MoveToTransferState_0:
   \   000000A8   050086E0           ADD      R0,R6,R5
   \   000000AC   010040E2           SUB      R0,R0,#+1
   \   000000B0   100084E5           STR      R0,[R4, #+16]
   1712            if(IsRead) {
   \   000000B4   000058E3           CMP      R8,#+0
   \   000000B8   1F00000A           BEQ      ??_MoveToTransferState_5
   1713              // Wait for card to be ready for data transfers
   1714              do {
   1715                Error = _SendCMD13(pInst, &Status);
   \                     ??_MoveToTransferState_6:
   \   000000BC   0D10A0E1           MOV      R1,SP
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           BL       _SendCMD13
   1716                if (Error) {
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   F3FFFF1A           BNE      ??_MoveToTransferState_4
   1717                  return Error;
   1718                }
   1719                if (((Status & STATUS_STATE) == STATUS_IDLE) || ((Status & STATUS_STATE) == STATUS_READY) || ((Status & STATUS_STATE) == STATUS_IDENT)) {
   \   000000D0   00009DE5           LDR      R0,[SP, #+0]
   \   000000D4   780D10E3           TST      R0,#0x1E00
   \   000000D8   780D0012           ANDNE    R0,R0,#0x1E00
   \   000000DC   800F5013           CMPNE    R0,#+512
   \   000000E0   00009D15           LDRNE    R0,[SP, #+0]
   \   000000E4   780D0012           ANDNE    R0,R0,#0x1E00
   \   000000E8   400E5013           CMPNE    R0,#+1024
   \   000000EC   0100001A           BNE      ??_MoveToTransferState_7
   1720                  FS_DEBUG_LOG((FS_MTYPE_DRIVER,"state = %x\n\r", (Status & STATUS_STATE) >> 9));
   1721                  return SD_ERROR_NOT_INITIALIZED;
   \                     ??_MoveToTransferState_8:
   \   000000F0   0300A0E3           MOV      R0,#+3
   \   000000F4   E9FFFFEA           B        ??_MoveToTransferState_4
   1722                }
   1723                // If the SD card is in sending data state or in receive data state
   1724                if (((Status & STATUS_STATE) == STATUS_RCV) || ((Status & STATUS_STATE) == STATUS_DATA) ){
   1725                  FS_DEBUG_LOG((FS_MTYPE_DRIVER,"state = %x\n\r", (Status & STATUS_STATE) >> 9));
   1726                }
   1727              } while (((Status & STATUS_READY_FOR_DATA) == 0) || ((Status & STATUS_STATE) != STATUS_TRAN));
   \                     ??_MoveToTransferState_7:
   \   000000F8   00009DE5           LDR      R0,[SP, #+0]
   \   000000FC   7C0D00E2           AND      R0,R0,#0x1F00
   \   00000100   900E50E3           CMP      R0,#+2304
   \   00000104   ECFFFF1A           BNE      ??_MoveToTransferState_6
   1728              if ((Status & STATUS_STATE) != STATUS_TRAN) {
   \   00000108   00009DE5           LDR      R0,[SP, #+0]
   \   0000010C   780D00E2           AND      R0,R0,#0x1E00
   \   00000110   800E50E3           CMP      R0,#+2048
   \   00000114   F5FFFF1A           BNE      ??_MoveToTransferState_8
   1729                FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "SD Card can't be configured in transfer state %x\n\r", (Status & STATUS_STATE) >> 9));
   1730                return SD_ERROR_NOT_INITIALIZED;
   1731              }
   1732              //
   1733              // Read data
   1734              // Move to Sending data state
   1735              //
   1736              Error = _SendCMD18(pInst, NumSectors, pData, SD_SECTOR_NO(pInst,SectorNo));
   \   00000118   4600D4E5           LDRB     R0,[R4, #+70]
   \   0000011C   0720A0E1           MOV      R2,R7
   \   00000120   0610A0E1           MOV      R1,R6
   \   00000124   020050E3           CMP      R0,#+2
   \   00000128   0530A001           MOVEQ    R3,R5
   \   0000012C   8534A011           LSLNE    R3,R5,#+9
   \   00000130   0400A0E1           MOV      R0,R4
   \   00000134   ........           BL       _SendCMD18
   1737              if (Error) {
   \   00000138   D8FFFFEA           B        ??_MoveToTransferState_4
   1738                return Error;
   1739              }
   1740            } else {
   1741              //
   1742              // Wait for card to be ready for data transfers
   1743              //
   1744              do {
   1745                Error = _SendCMD13(pInst, &Status);
   \                     ??_MoveToTransferState_5:
   \   0000013C   0D10A0E1           MOV      R1,SP
   \   00000140   0400A0E1           MOV      R0,R4
   \   00000144   ........           BL       _SendCMD13
   1746                if (Error) {
   \   00000148   000050E3           CMP      R0,#+0
   \   0000014C   D3FFFF1A           BNE      ??_MoveToTransferState_4
   1747                  return Error;
   1748                }
   1749              }  while ((Status & STATUS_READY_FOR_DATA) == 0);
   \   00000150   00009DE5           LDR      R0,[SP, #+0]
   \   00000154   400F10E3           TST      R0,#0x100
   \   00000158   F7FFFF0A           BEQ      ??_MoveToTransferState_5
   1750              //
   1751              // If the SD card is in standby state go in transfer state
   1752              //
   1753              if ((Status & STATUS_STATE) == STATUS_STBY) {
   \   0000015C   780D00E2           AND      R0,R0,#0x1E00
   \   00000160   600E50E3           CMP      R0,#+1536
   \   00000164   2200001A           BNE      ??_MoveToTransferState_9
   1754                //
   1755                // Go into transfer state
   1756                //
   1757                Error = _SendCMD7(pInst, pInst->CardAddress);
   \   00000168   1C9084E2           ADD      R9,R4,#+28
   \   0000016C   B084D4E1           LDRH     R8,[R4, #+64]
   \   00000170   2410A0E3           MOV      R1,#+36
   \   00000174   0900A0E1           MOV      R0,R9
   \   00000178   ........           BL       __aeabi_memclr4
   \   0000017C   4700A0E3           MOV      R0,#+71
   \   00000180   400D80E3           ORR      R0,R0,#0x1000
   \   00000184   000089E5           STR      R0,[R9, #+0]
   \   00000188   0808A0E1           LSL      R0,R8,#+16
   \   0000018C   040089E5           STR      R0,[R9, #+4]
   \   00000190   0000A0E3           MOV      R0,#+0
   \   00000194   4500C4E5           STRB     R0,[R4, #+69]
   \   00000198   0400A0E1           MOV      R0,R4
   \   0000019C   ........           BL       __SendCommand
   \   000001A0   000050E3           CMP      R0,#+0
   \   000001A4   0100000A           BEQ      ??_MoveToTransferState_10
   \                     ??_MoveToTransferState_1:
   \   000001A8   0100A0E3           MOV      R0,#+1
   \   000001AC   BBFFFFEA           B        ??_MoveToTransferState_4
   \                     ??_MoveToTransferState_10:
   \   000001B0   000099E5           LDR      R0,[R9, #+0]
   \   000001B4   4C10A0E3           MOV      R1,#+76
   \   000001B8   841B81E3           ORR      R1,R1,#0x21000
   \   000001BC   010050E1           CMP      R0,R1
   \   000001C0   0800001A           BNE      ??_MoveToTransferState_11
   \                     ??_MoveToTransferState_12:
   \   000001C4   180094E5           LDR      R0,[R4, #+24]
   \   000001C8   0110A0E3           MOV      R1,#+1
   \   000001CC   001080E5           STR      R1,[R0, #+0]
   \   000001D0   401090E5           LDR      R1,[R0, #+64]
   \   000001D4   301001E2           AND      R1,R1,#0x30
   \   000001D8   200051E3           CMP      R1,#+32
   \   000001DC   F8FFFF1A           BNE      ??_MoveToTransferState_12
   \   000001E0   0210A0E3           MOV      R1,#+2
   \   000001E4   001080E5           STR      R1,[R0, #+0]
   \                     ??_MoveToTransferState_11:
   \   000001E8   1000D9E5           LDRB     R0,[R9, #+16]
   1758                if (Error) {
   \   000001EC   000050E3           CMP      R0,#+0
   \   000001F0   AAFFFF1A           BNE      ??_MoveToTransferState_4
   1759                  return Error;
   1760                }
   1761              }
   1762              //
   1763              // Move to Sending data state
   1764              //
   1765              Error = _SendCMD25(pInst, NumSectors, pData, SD_SECTOR_NO(pInst,SectorNo));
   \                     ??_MoveToTransferState_9:
   \   000001F4   4600D4E5           LDRB     R0,[R4, #+70]
   \   000001F8   0720A0E1           MOV      R2,R7
   \   000001FC   0610A0E1           MOV      R1,R6
   \   00000200   020050E3           CMP      R0,#+2
   \   00000204   8554A011           LSLNE    R5,R5,#+9
   \   00000208   0530A0E1           MOV      R3,R5
   \   0000020C   0400A0E1           MOV      R0,R4
   \   00000210   ........           BL       _SendCMD25
   1766              if (Error) {
   \   00000214   A1FFFFEA           B        ??_MoveToTransferState_4
   1767                return Error;
   1768              }
   1769            }
   1770            return Error;
   1771          }
   1772          
   1773          
   1774          
   1775          /*********************************************************************
   1776          *
   1777          *       _ReadSectors
   1778          *
   1779          *  Function description:
   1780          *    Read Block of data in a buffer pointed by pData. The buffer size must be at
   1781          *    least 512 byte long. This function checks the SD card Status register and
   1782          *    address the card if required before sending the read command.
   1783          *
   1784          *  Parameters:
   1785          *    Unit       - Unit number, which instance shall be used.
   1786          *    SectorNo   - Sector that shall be read
   1787          *    NumSectors - Number of sector to read
   1788          *    pData      - Pointer to the data buffer to store read data
   1789          *
   1790          *  Return value:
   1791          *    0 if successful
   1792          *    otherwise returns an code describing the Error.
   1793          *
   1794          */
   1795          static U8 _ReadSectors(U8 Unit, U32 SectorNo, U8 * p, unsigned NumSectors) {
   1796            U8 Error;
   1797            DRIVER_INST * pInst;
   1798          
   1799            pInst = _apInst[Unit];
   1800            if((pInst->State == SD_STATE_DATA) && ((pInst->PreSector + 1) == SectorNo)) {
   1801              Error = _ContinuousRead(pInst, NumSectors, p, SD_SECTOR_NO(pInst,SectorNo));
   1802              pInst->PreSector = SectorNo + (NumSectors-1);
   1803            } else {
   1804              Error = _MoveToTransferState(pInst, SectorNo, NumSectors, p, 1);
   1805            }
   1806            return Error;
   1807          }
   1808          
   1809          /*********************************************************************
   1810          *
   1811          *       _WriteSectors
   1812          *
   1813          *  Function description:
   1814          *    Write Block of data pointed by pData. The buffer size must be at
   1815          *    least 512 byte long. This function checks the SD card Status register and
   1816          *    address the card if required before sending the write command.
   1817          *
   1818          *  Parameters:
   1819          *    Unit       - Unit number, which instance shall be used.
   1820          *    SectorNo   - Sector that shall be written
   1821          *    NumSectors - Number of sector to write
   1822          *    pData      - Pointer to the data buffer to holds the data
   1823          *
   1824          *  Return value:
   1825          *    Returns 0 if successful
   1826          *    Otherwise returns an SD_ERROR code.
   1827          *
   1828          */
   1829          static U8 _WriteSectors(U8 Unit, U32 SectorNo, const U8 * p, unsigned NumSectors) {
   1830            U8 Error;
   1831            DRIVER_INST * pInst;
   1832          
   1833            pInst = _apInst[Unit];
   1834            if (pInst->IsWriteProtected) {
   1835              return 1;
   1836            }
   1837            if((pInst->State == SD_STATE_RCV)  && ((pInst->PreSector + 1) == SectorNo)) {
   1838              Error = _ContinuousWrite(pInst, NumSectors, p, SD_SECTOR_NO(pInst,SectorNo));
   1839              pInst->PreSector = SectorNo + (NumSectors-1);
   1840            } else {
   1841              Error = _MoveToTransferState(pInst, SectorNo, NumSectors, (U8 *)p, 0);
   1842            }
   1843            return Error;
   1844          }
   1845          
   1846          /*********************************************************************
   1847          *
   1848          *       _Init
   1849          *
   1850          *  Function description:
   1851          *    Run the SDcard initialization sequence. This function runs the initialization
   1852          *    procedure and the identification process, then it sets the SD card in transfer
   1853          *    state to set the block length and the bus width.
   1854          *
   1855          *  Parameters:
   1856          *    Unit       - Unit number, which instance shall be used.
   1857          *
   1858          *  Return value:
   1859          *    Returns 0 if successful; otherwise returns an code describing the Error.
   1860          *
   1861          */

   \                                 In section .text, align 4, keep-with-next
   1862          static U8 _Init(U8 Unit) {
   \                     _Init:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   1863            U32             sdCid[4];
   1864            U8              IsCCSet;
   1865            U32             Status;
   1866            U8              Error;
   1867            U8              cmd8Retries = 2;
   1868            U8              Cmd1Retries = 100;
   1869            DRIVER_INST   * pInst;
   1870          
   1871            FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- _Init()\n\r"));
   1872            //
   1873            // Initialize the MCI driver
   1874            //
   1875            pInst  = _apInst[Unit];
   \   00000004   ........           LDR      R1,??DataTable13_1
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   008191E7           LDR      R8,[R1, +R0, LSL #+2]
   \   00000010   24D04DE2           SUB      SP,SP,#+36
   \   00000014   0250A0E3           MOV      R5,#+2
   \   00000018   0260A0E3           MOV      R6,#+2
   \   0000001C   6470A0E3           MOV      R7,#+100
   1876            _InitMCI(pInst);
   \   00000020   4800D8E5           LDRB     R0,[R8, #+72]
   \   00000024   ........           BL       FS_MCI_HW_Init
   \   00000028   0C108DE2           ADD      R1,SP,#+12
   \   0000002C   4800D8E5           LDRB     R0,[R8, #+72]
   \   00000030   ........           BL       FS_MCI_HW_GetMCIInfo
   \   00000034   0CA09DE5           LDR      R10,[SP, #+12]
   \   00000038   10909DE5           LDR      R9,[SP, #+16]
   \   0000003C   18A088E5           STR      R10,[R8, #+24]
   \   00000040   0110A0E3           MOV      R1,#+1
   \   00000044   4800D8E5           LDRB     R0,[R8, #+72]
   \   00000048   ........           BL       FS_MCI_HW_EnableClock
   \   0000004C   8000A0E3           MOV      R0,#+128
   \   00000050   00008AE5           STR      R0,[R10, #+0]
   \   00000054   0A00A0E3           MOV      R0,#+10
   \   00000058   00008AE5           STR      R0,[R10, #+0]
   \   0000005C   00B0E0E3           MVN      R11,#+0
   \   00000060   48B08AE5           STR      R11,[R10, #+72]
   \   00000064   7F00A0E3           MOV      R0,#+127
   \   00000068   08008AE5           STR      R0,[R10, #+8]
   \   0000006C   4800D8E5           LDRB     R0,[R8, #+72]
   \   00000070   ........           BL       FS_MCI_HW_GetMClk
   \   00000074   ........           LDR      R2,??DataTable13_2  ;; 0xa7c5ac47
   \   00000078   0010A0E3           MOV      R1,#+0
   \   0000007C   9022A1E0           UMLAL    R2,R1,R0,R2
   \   00000080   A1098BE0           ADD      R0,R11,R1, LSR #+19
   \   00000084   700E80E3           ORR      R0,R0,#0x700
   \   00000088   04008AE5           STR      R0,[R10, #+4]
   \   0000008C   0C908AE5           STR      R9,[R10, #+12]
   \   00000090   0190A0E3           MOV      R9,#+1
   \   00000094   00908AE5           STR      R9,[R10, #+0]
   \   00000098   0010A0E3           MOV      R1,#+0
   \   0000009C   4800D8E5           LDRB     R0,[R8, #+72]
   \   000000A0   ........           BL       FS_MCI_HW_EnableClock
   \   000000A4   ........           LDR      R1,??DataTable13_3
   \   000000A8   4800D8E5           LDRB     R0,[R8, #+72]
   \   000000AC   ........           BL       FS_MCI_HW_EnableISR
   1877            //
   1878            // Initialize DRIVER_INST structure
   1879            //
   1880            pInst->CardAddress = 0;
   \   000000B0   00A0A0E3           MOV      R10,#+0
   \   000000B4   B0A4C8E1           STRH     R10,[R8, #+64]
   1881            pInst->PreSector   = 0xffffffff;
   \   000000B8   10B088E5           STR      R11,[R8, #+16]
   1882            pInst->State       = SD_STATE_STBY;
   \   000000BC   45A0C8E5           STRB     R10,[R8, #+69]
   1883            pInst->CardType    = UNKNOWN_CARD;
   \   000000C0   46A0C8E5           STRB     R10,[R8, #+70]
   1884            ZEROFILL(&(pInst->Command), sizeof(MCI_CMD));
   \   000000C4   2410A0E3           MOV      R1,#+36
   \   000000C8   1C0088E2           ADD      R0,R8,#+28
   \   000000CC   ........           BL       __aeabi_memclr4
   1885            //
   1886            // Initialization delay: The maximum of 1 msec, 74 clock cycles and supply ramp up time
   1887            // Supply ramp up time provides the time that the power is built up to the operating level (the bus
   1888            // master supply voltage) and the time to wait until the SD card can accept the first command
   1889            // Power On Init Special Command
   1890            //
   1891            FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Pon()\n\r"));
   1892            Error = _PowerOn(pInst);
   \   000000D0   1CB088E2           ADD      R11,R8,#+28
   \   000000D4   2410A0E3           MOV      R1,#+36
   \   000000D8   0B00A0E1           MOV      R0,R11
   \   000000DC   ........           BL       __aeabi_memclr4
   \   000000E0   900EA0E3           MOV      R0,#+2304
   \   000000E4   00008BE5           STR      R0,[R11, #+0]
   \   000000E8   45A0C8E5           STRB     R10,[R8, #+69]
   \   000000EC   0800A0E1           MOV      R0,R8
   \   000000F0   ........           BL       __SendCommand
   \   000000F4   000050E3           CMP      R0,#+0
   \   000000F8   0100A013           MOVNE    R0,#+1
   \   000000FC   0C00001A           BNE      ??_Init_0
   \   00000100   00009BE5           LDR      R0,[R11, #+0]
   \   00000104   4C10A0E3           MOV      R1,#+76
   \   00000108   841B81E3           ORR      R1,R1,#0x21000
   \   0000010C   010050E1           CMP      R0,R1
   \   00000110   0600001A           BNE      ??_Init_1
   \                     ??_Init_2:
   \   00000114   180098E5           LDR      R0,[R8, #+24]
   \   00000118   009080E5           STR      R9,[R0, #+0]
   \   0000011C   401090E5           LDR      R1,[R0, #+64]
   \   00000120   301001E2           AND      R1,R1,#0x30
   \   00000124   200051E3           CMP      R1,#+32
   \   00000128   F9FFFF1A           BNE      ??_Init_2
   \   0000012C   005080E5           STR      R5,[R0, #+0]
   \                     ??_Init_1:
   \   00000130   1000DBE5           LDRB     R0,[R11, #+16]
   \                     ??_Init_0:
   \   00000134   C820A0E3           MOV      R2,#+200
   \   00000138   00208DE5           STR      R2,[SP, #+0]
   \                     ??_Init_3:
   \   0000013C   00109DE5           LDR      R1,[SP, #+0]
   \   00000140   011051E2           SUBS     R1,R1,#+1
   \   00000144   00108DE5           STR      R1,[SP, #+0]
   \   00000148   FBFFFF1A           BNE      ??_Init_3
   1893            if (Error) {
   \   0000014C   000050E3           CMP      R0,#+0
   \   00000150   0A01001A           BNE      ??_Init_4
   1894              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   1895              return Error;
   1896            }
   1897            //
   1898            // The command GO_IDLE_STATE (CMD0) is the software reset command and sets card into Idle State
   1899            // regardless of the current card state.
   1900            //
   1901            FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Cmd0()\n\r"));
   1902            Error = _SendCMD0(pInst);
   \   00000154   2410A0E3           MOV      R1,#+36
   \   00000158   0B00A0E1           MOV      R0,R11
   \   0000015C   ........           BL       __aeabi_memclr4
   \   00000160   00A08BE5           STR      R10,[R11, #+0]
   \   00000164   45A0C8E5           STRB     R10,[R8, #+69]
   \   00000168   0800A0E1           MOV      R0,R8
   \   0000016C   ........           BL       __SendCommand
   \   00000170   000050E3           CMP      R0,#+0
   \   00000174   0100A013           MOVNE    R0,#+1
   \   00000178   0C00001A           BNE      ??_Init_5
   \   0000017C   00009BE5           LDR      R0,[R11, #+0]
   \   00000180   4C10A0E3           MOV      R1,#+76
   \   00000184   841B81E3           ORR      R1,R1,#0x21000
   \   00000188   010050E1           CMP      R0,R1
   \   0000018C   0600001A           BNE      ??_Init_6
   \                     ??_Init_7:
   \   00000190   180098E5           LDR      R0,[R8, #+24]
   \   00000194   009080E5           STR      R9,[R0, #+0]
   \   00000198   401090E5           LDR      R1,[R0, #+64]
   \   0000019C   301001E2           AND      R1,R1,#0x30
   \   000001A0   200051E3           CMP      R1,#+32
   \   000001A4   F9FFFF1A           BNE      ??_Init_7
   \   000001A8   005080E5           STR      R5,[R0, #+0]
   \                     ??_Init_6:
   \   000001AC   1000DBE5           LDRB     R0,[R11, #+16]
   \                     ??_Init_5:
   \   000001B0   C820A0E3           MOV      R2,#+200
   \   000001B4   00208DE5           STR      R2,[SP, #+0]
   \                     ??_Init_8:
   \   000001B8   00109DE5           LDR      R1,[SP, #+0]
   \   000001BC   011051E2           SUBS     R1,R1,#+1
   \   000001C0   00108DE5           STR      R1,[SP, #+0]
   \   000001C4   FBFFFF1A           BNE      ??_Init_8
   1903            if (Error) {
   \   000001C8   000050E3           CMP      R0,#+0
   \   000001CC   EB00001A           BNE      ??_Init_4
   1904              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   1905              return Error;
   1906            }
   1907            //
   1908            // After power-on or CMD0, all cards CMD lines are in input mode, waiting for start bit of the next command.
   1909            // The cards are initialized with a default relative card address (RCA=0x0000) and with a default
   1910            // driver stage register setting (lowest speed, highest driving current capability).
   1911            // CMD8 is newly added in the Physical Layer Specification Version 2.00 to support multiple voltage
   1912            // ranges and used to check whether the card supports supplied voltage. The version 2.00 host shall
   1913            // issue CMD8 and verify voltage before card initialization.
   1914            // The host that does not support CMD8 shall supply high voltage range...
   1915            //
   1916            FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Cmd8()\n\r"));
   1917            do {
   1918              Error = _SendCMD8(pInst, 1);
   \                     ??_Init_9:
   \   000001D0   0110A0E3           MOV      R1,#+1
   \   000001D4   0800A0E1           MOV      R0,R8
   \   000001D8   ........           BL       _SendCMD8
   1919            } while ((Error == SD_ERROR_NORESPONSE) && (cmd8Retries-- > 0));
   \   000001DC   020050E3           CMP      R0,#+2
   \   000001E0   1500001A           BNE      ??_Init_10
   \   000001E4   0600A0E1           MOV      R0,R6
   \   000001E8   016040E2           SUB      R6,R0,#+1
   \   000001EC   000CB0E1           LSLS     R0,R0,#+24
   \   000001F0   F6FFFF1A           BNE      ??_Init_9
   1920            if (Error == SD_ERROR_NORESPONSE) {
   1921              //
   1922              // No response : Ver2.00 or later SD Memory Card(voltage mismatch)
   1923              // or Ver1.X SD Memory Card
   1924              // or not SD Memory Card
   1925              //
   1926              FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- No response to Cmd8\n\r"));
   1927              //
   1928              // ACMD41 is a synchronization command used to negotiate the operation voltage range and to poll the
   1929              // cards until they are out of their power-up sequence.
   1930              //
   1931              FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Acmd41()\n\r"));
   1932              Error = _SendACMD41(pInst, 0, &IsCCSet);
   1933              if (Error) {
   \   000001F4   04208DE2           ADD      R2,SP,#+4
   \   000001F8   0010A0E3           MOV      R1,#+0
   \   000001FC   0800A0E1           MOV      R0,R8
   \   00000200   ........           BL       _SendACMD41
   \   00000204   000050E3           CMP      R0,#+0
   \   00000208   3900000A           BEQ      ??_Init_11
   1934                //
   1935                // Acmd41 failed : MMC card or unknown card
   1936                //
   1937                Error = _SendCMD0(pInst);
   \   0000020C   1C6088E2           ADD      R6,R8,#+28
   \   00000210   2410A0E3           MOV      R1,#+36
   \   00000214   0600A0E1           MOV      R0,R6
   \   00000218   ........           BL       __aeabi_memclr4
   \   0000021C   00A086E5           STR      R10,[R6, #+0]
   \   00000220   45A0C8E5           STRB     R10,[R8, #+69]
   \   00000224   0800A0E1           MOV      R0,R8
   \   00000228   ........           BL       __SendCommand
   \   0000022C   000050E3           CMP      R0,#+0
   \   00000230   0E00000A           BEQ      ??_Init_12
   \   00000234   0100A0E3           MOV      R0,#+1
   \   00000238   190000EA           B        ??_Init_13
   1938                if (Error) {
   1939                  FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   1940                  return Error;
   1941                }
   1942                do {
   1943                  Error = _SendCMD1(pInst);
   1944                } while ((Error) && (Cmd1Retries-- > 0));
   1945                if (Error) {
   1946                  FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   1947                  return Error;
   1948                } else {
   1949                  pInst->CardType = CARD_MMC;
   1950                }
   1951              } else {
   1952                if(IsCCSet == 0) {
   1953                  pInst->CardType = CARD_SD;
   1954                }
   1955              }
   1956            } else if (!Error) {
   \                     ??_Init_10:
   \   0000023C   000050E3           CMP      R0,#+0
   \   00000240   CE00001A           BNE      ??_Init_4
   1957              //
   1958              // Valid response : Ver2.00 or later SD Memory Card
   1959              //
   1960              FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Acmd41()\n\r"));
   1961              Error = _SendACMD41(pInst, 1, &IsCCSet);
   \   00000244   04208DE2           ADD      R2,SP,#+4
   \   00000248   0110A0E3           MOV      R1,#+1
   \   0000024C   0800A0E1           MOV      R0,R8
   \   00000250   ........           BL       _SendACMD41
   1962              if (Error) {
   \   00000254   000050E3           CMP      R0,#+0
   \   00000258   C800001A           BNE      ??_Init_4
   1963                FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   1964                return Error;
   1965              }
   1966              if (IsCCSet) {
   \   0000025C   0400DDE5           LDRB     R0,[SP, #+4]
   \   00000260   000050E3           CMP      R0,#+0
   \   00000264   2500000A           BEQ      ??_Init_14
   1967                pInst->CardType = CARD_SDHC;
   \   00000268   4650C8E5           STRB     R5,[R8, #+70]
   \   0000026C   240000EA           B        ??_Init_15
   \                     ??_Init_12:
   \   00000270   000096E5           LDR      R0,[R6, #+0]
   \   00000274   4C10A0E3           MOV      R1,#+76
   \   00000278   841B81E3           ORR      R1,R1,#0x21000
   \   0000027C   010050E1           CMP      R0,R1
   \   00000280   0600001A           BNE      ??_Init_16
   \                     ??_Init_17:
   \   00000284   180098E5           LDR      R0,[R8, #+24]
   \   00000288   009080E5           STR      R9,[R0, #+0]
   \   0000028C   401090E5           LDR      R1,[R0, #+64]
   \   00000290   301001E2           AND      R1,R1,#0x30
   \   00000294   200051E3           CMP      R1,#+32
   \   00000298   F9FFFF1A           BNE      ??_Init_17
   \   0000029C   005080E5           STR      R5,[R0, #+0]
   \                     ??_Init_16:
   \   000002A0   1000D6E5           LDRB     R0,[R6, #+16]
   \                     ??_Init_13:
   \   000002A4   C820A0E3           MOV      R2,#+200
   \   000002A8   00208DE5           STR      R2,[SP, #+0]
   \                     ??_Init_18:
   \   000002AC   00109DE5           LDR      R1,[SP, #+0]
   \   000002B0   011051E2           SUBS     R1,R1,#+1
   \   000002B4   00108DE5           STR      R1,[SP, #+0]
   \   000002B8   FBFFFF1A           BNE      ??_Init_18
   1968              } else {
   \   000002BC   000050E3           CMP      R0,#+0
   \   000002C0   AE00001A           BNE      ??_Init_4
   \                     ??_Init_19:
   \   000002C4   0800A0E1           MOV      R0,R8
   \   000002C8   ........           BL       _SendCMD1
   \   000002CC   000050E3           CMP      R0,#+0
   \   000002D0   0400000A           BEQ      ??_Init_20
   \   000002D4   0710A0E1           MOV      R1,R7
   \   000002D8   017041E2           SUB      R7,R1,#+1
   \   000002DC   011CB0E1           LSLS     R1,R1,#+24
   \   000002E0   F7FFFF1A           BNE      ??_Init_19
   \   000002E4   A50000EA           B        ??_Init_4
   \                     ??_Init_20:
   \   000002E8   0300A0E3           MOV      R0,#+3
   \   000002EC   4600C8E5           STRB     R0,[R8, #+70]
   \   000002F0   030000EA           B        ??_Init_15
   \                     ??_Init_11:
   \   000002F4   0400DDE5           LDRB     R0,[SP, #+4]
   \   000002F8   000050E3           CMP      R0,#+0
   \   000002FC   0000001A           BNE      ??_Init_15
   1969                pInst->CardType = CARD_SD;
   \                     ??_Init_14:
   \   00000300   4690C8E5           STRB     R9,[R8, #+70]
   1970              }
   1971            } else {
   1972              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   1973              return Error;
   1974            }
   1975            //
   1976            // The host then issues the command ALL_SEND_CID (CMD2) to the card to get its unique card identification (CID) number.
   1977            // Card that is unidentified (i.e. which is in Ready State) sends its CID number as the response (on the CMD line).
   1978            //
   1979            FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Cmd2()\n\r"));
   1980            Error = _SendCMD2(pInst, sdCid);
   \                     ??_Init_15:
   \   00000304   1C6088E2           ADD      R6,R8,#+28
   \   00000308   2410A0E3           MOV      R1,#+36
   \   0000030C   0600A0E1           MOV      R0,R6
   \   00000310   ........           BL       __aeabi_memclr4
   \   00000314   8200A0E3           MOV      R0,#+130
   \   00000318   000086E5           STR      R0,[R6, #+0]
   \   0000031C   0400A0E3           MOV      R0,#+4
   \   00000320   0E00C6E5           STRB     R0,[R6, #+14]
   \   00000324   14008DE2           ADD      R0,SP,#+20
   \   00000328   180086E5           STR      R0,[R6, #+24]
   \   0000032C   45A0C8E5           STRB     R10,[R8, #+69]
   \   00000330   1C7088E2           ADD      R7,R8,#+28
   \   00000334   0800A0E1           MOV      R0,R8
   \   00000338   ........           BL       __SendCommand
   \   0000033C   000050E3           CMP      R0,#+0
   \   00000340   5700001A           BNE      ??_Init_21
   \   00000344   4C60A0E3           MOV      R6,#+76
   \   00000348   000097E5           LDR      R0,[R7, #+0]
   \   0000034C   846B86E3           ORR      R6,R6,#0x21000
   \   00000350   060050E1           CMP      R0,R6
   \   00000354   0600001A           BNE      ??_Init_22
   \                     ??_Init_23:
   \   00000358   180098E5           LDR      R0,[R8, #+24]
   \   0000035C   009080E5           STR      R9,[R0, #+0]
   \   00000360   401090E5           LDR      R1,[R0, #+64]
   \   00000364   301001E2           AND      R1,R1,#0x30
   \   00000368   200051E3           CMP      R1,#+32
   \   0000036C   F9FFFF1A           BNE      ??_Init_23
   \   00000370   005080E5           STR      R5,[R0, #+0]
   \                     ??_Init_22:
   \   00000374   1000D7E5           LDRB     R0,[R7, #+16]
   1981            if (Error) {
   \   00000378   000050E3           CMP      R0,#+0
   \   0000037C   7F00001A           BNE      ??_Init_4
   1982              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   1983              return Error;
   1984            }
   1985            //
   1986            // Thereafter, the host issues CMD3 (SEND_RELATIVE_ADDR) asks the
   1987            // card to publish a new relative card address (RCA), which is shorter than CID and which is used to
   1988            // address the card in the future data transfer mode. Once the RCA is received the card state changes to
   1989            // the Stand-by State. At this point, if the host wants to assign another RCA number, it can ask the card to
   1990            // publish a new number by sending another CMD3 command to the card. The last published RCA is the
   1991            // actual RCA number of the card.
   1992            //
   1993            FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Cmd3()\n\r"));
   1994            Error = _SendCMD3(pInst);
   \   00000380   0800A0E1           MOV      R0,R8
   \   00000384   ........           BL       _SendCMD3
   1995            if (Error) {
   \   00000388   000050E3           CMP      R0,#+0
   \   0000038C   7B00001A           BNE      ??_Init_4
   1996              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   1997              return Error;
   1998            }
   1999            //
   2000            // The host issues SEND_CSD (CMD9) to obtain the Card Specific Data (CSD register),
   2001            // e.g. block length, card storage capacity, etc...
   2002            //
   2003            FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Cmd9()\n\r"));
   2004            Error = _SendCMD9(pInst);
   \   00000390   0800A0E1           MOV      R0,R8
   \   00000394   ........           BL       _SendCMD9
   2005            if (Error) {
   \   00000398   000050E3           CMP      R0,#+0
   \   0000039C   7700001A           BNE      ??_Init_4
   2006              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   2007              return Error;
   2008            }
   2009            //
   2010            // At this stage the Initialization and identification process is achieved
   2011            // The SD card is supposed to be in Stand-by State
   2012            //
   2013            FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Cmd13()\n\r"));
   2014            do {
   2015              Error = _SendCMD13(pInst, &Status);
   \                     ??_Init_24:
   \   000003A0   08108DE2           ADD      R1,SP,#+8
   \   000003A4   0800A0E1           MOV      R0,R8
   \   000003A8   ........           BL       _SendCMD13
   2016              if (Error) {
   \   000003AC   000050E3           CMP      R0,#+0
   \   000003B0   7200001A           BNE      ??_Init_4
   2017                FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   2018                return Error;
   2019              }
   2020            } while ((Status & STATUS_READY_FOR_DATA) == 0);
   \   000003B4   08009DE5           LDR      R0,[SP, #+8]
   \   000003B8   400F10E3           TST      R0,#0x100
   \   000003BC   F7FFFF0A           BEQ      ??_Init_24
   2021            //
   2022            // If the 4 bit bus transfer is supported switch to this mode
   2023            // Select the current SD, goto transfer state
   2024            //
   2025            FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Cmd7()\n\r"));
   2026            Error = _SendCMD7(pInst, pInst->CardAddress);
   \   000003C0   B074D8E1           LDRH     R7,[R8, #+64]
   \   000003C4   2410A0E3           MOV      R1,#+36
   \   000003C8   0B00A0E1           MOV      R0,R11
   \   000003CC   ........           BL       __aeabi_memclr4
   \   000003D0   4700A0E3           MOV      R0,#+71
   \   000003D4   400D80E3           ORR      R0,R0,#0x1000
   \   000003D8   00008BE5           STR      R0,[R11, #+0]
   \   000003DC   0708A0E1           LSL      R0,R7,#+16
   \   000003E0   04008BE5           STR      R0,[R11, #+4]
   \   000003E4   45A0C8E5           STRB     R10,[R8, #+69]
   \   000003E8   1C7088E2           ADD      R7,R8,#+28
   \   000003EC   0800A0E1           MOV      R0,R8
   \   000003F0   ........           BL       __SendCommand
   \   000003F4   000050E3           CMP      R0,#+0
   \   000003F8   2900001A           BNE      ??_Init_21
   \   000003FC   000097E5           LDR      R0,[R7, #+0]
   \   00000400   060050E1           CMP      R0,R6
   \   00000404   0600001A           BNE      ??_Init_25
   \                     ??_Init_26:
   \   00000408   180098E5           LDR      R0,[R8, #+24]
   \   0000040C   009080E5           STR      R9,[R0, #+0]
   \   00000410   401090E5           LDR      R1,[R0, #+64]
   \   00000414   301001E2           AND      R1,R1,#0x30
   \   00000418   200051E3           CMP      R1,#+32
   \   0000041C   F9FFFF1A           BNE      ??_Init_26
   \   00000420   005080E5           STR      R5,[R0, #+0]
   \                     ??_Init_25:
   \   00000424   1000D7E5           LDRB     R0,[R7, #+16]
   2027            if (Error) {
   \   00000428   000050E3           CMP      R0,#+0
   \   0000042C   5300001A           BNE      ??_Init_4
   2028              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   2029              return Error;
   2030            }
   2031            if (pInst->CardType != CARD_MMC) {
   \   00000430   4600D8E5           LDRB     R0,[R8, #+70]
   \   00000434   030050E3           CMP      R0,#+3
   \   00000438   0500000A           BEQ      ??_Init_27
   2032              //
   2033              // Switch to 4 bits bus width (All SD Card shall support 1-bit, 4 bitswidth
   2034              //
   2035              FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Acmd6()\n\r"));
   2036              Error = _SendACMD6(pInst, 4);
   \   0000043C   0410A0E3           MOV      R1,#+4
   \   00000440   0800A0E1           MOV      R0,R8
   \   00000444   ........           BL       _SendACMD6
   2037              if (Error) {
   \   00000448   000050E3           CMP      R0,#+0
   \   0000044C   4B00001A           BNE      ??_Init_4
   \   00000450   030000EA           B        ??_Init_28
   2038                FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   2039                return Error;
   2040              }
   2041            } else {
   2042              _SetBusWidth(pInst, MCI_SDCBUS_1BIT);
   \                     ??_Init_27:
   \   00000454   180098E5           LDR      R0,[R8, #+24]
   \   00000458   0C1090E5           LDR      R1,[R0, #+12]
   \   0000045C   8010C1E3           BIC      R1,R1,#0x80
   \   00000460   0C1080E5           STR      R1,[R0, #+12]
   2043            }
   2044            //
   2045            // In the case of a Standard Capacity SD Memory Card, this command sets the
   2046            // block length (in bytes) for all following block commands (read, write, lock).
   2047            // Default block length is fixed to 512 Bytes.
   2048            // Set length is valid for memory access commands only if partial block read
   2049            // operation are allowed in CSD.
   2050            // In the case of a High Capacity SD Memory Card, block length set by CMD16
   2051            // command does not affect the memory read and write commands. Always 512
   2052            // Bytes fixed block length is used. This command is effective for LOCK_UNLOCK command.
   2053            // In both cases, if block length is set larger than 512Bytes, the card sets the
   2054            // BLOCK_LEN_ERROR bit.
   2055            //
   2056            if (pInst->CardType == CARD_SD) {
   \                     ??_Init_28:
   \   00000464   4600D8E5           LDRB     R0,[R8, #+70]
   \   00000468   010050E3           CMP      R0,#+1
   \   0000046C   1B00001A           BNE      ??_Init_29
   2057              FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Cmd16()\n\r"));
   2058              Error = _SendCMD16(pInst, SECTOR_SIZE);
   \   00000470   2410A0E3           MOV      R1,#+36
   \   00000474   0700A0E1           MOV      R0,R7
   \   00000478   ........           BL       __aeabi_memclr4
   \   0000047C   5000A0E3           MOV      R0,#+80
   \   00000480   400D80E3           ORR      R0,R0,#0x1000
   \   00000484   000087E5           STR      R0,[R7, #+0]
   \   00000488   800FA0E3           MOV      R0,#+512
   \   0000048C   040087E5           STR      R0,[R7, #+4]
   \   00000490   45A0C8E5           STRB     R10,[R8, #+69]
   \   00000494   0800A0E1           MOV      R0,R8
   \   00000498   ........           BL       __SendCommand
   \   0000049C   000050E3           CMP      R0,#+0
   \   000004A0   0100000A           BEQ      ??_Init_30
   \                     ??_Init_21:
   \   000004A4   0100A0E3           MOV      R0,#+1
   \   000004A8   340000EA           B        ??_Init_4
   \                     ??_Init_30:
   \   000004AC   000097E5           LDR      R0,[R7, #+0]
   \   000004B0   060050E1           CMP      R0,R6
   \   000004B4   0600001A           BNE      ??_Init_31
   \                     ??_Init_32:
   \   000004B8   180098E5           LDR      R0,[R8, #+24]
   \   000004BC   009080E5           STR      R9,[R0, #+0]
   \   000004C0   401090E5           LDR      R1,[R0, #+64]
   \   000004C4   301001E2           AND      R1,R1,#0x30
   \   000004C8   200051E3           CMP      R1,#+32
   \   000004CC   F9FFFF1A           BNE      ??_Init_32
   \   000004D0   005080E5           STR      R5,[R0, #+0]
   \                     ??_Init_31:
   \   000004D4   1000D7E5           LDRB     R0,[R7, #+16]
   2059              if (Error) {
   \   000004D8   000050E3           CMP      R0,#+0
   \   000004DC   2700001A           BNE      ??_Init_4
   2060                FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Error during initialization (%d)\n\r", Error));
   2061                return Error;
   2062              }
   2063            }
   2064            if(pInst->CardType != CARD_SDHC) {
   \                     ??_Init_29:
   \   000004E0   4620D8E5           LDRB     R2,[R8, #+70]
   \   000004E4   080098E5           LDR      R0,[R8, #+8]
   \   000004E8   041098E5           LDR      R1,[R8, #+4]
   \   000004EC   020052E3           CMP      R2,#+2
   \   000004F0   0A00000A           BEQ      ??_Init_33
   2065              pInst->NumSectors = SD_CSD_BLOCKNR(pInst);
   \   000004F4   202FA0E1           LSR      R2,R0,#+30
   \   000004F8   011BA0E1           LSL      R1,R1,#+22
   \   000004FC   A007A0E1           LSR      R0,R0,#+15
   \   00000500   211BA0E1           LSR      R1,R1,#+22
   \   00000504   070000E2           AND      R0,R0,#0x7
   \   00000508   011182E0           ADD      R1,R2,R1, LSL #+2
   \   0000050C   020080E2           ADD      R0,R0,#+2
   \   00000510   011081E2           ADD      R1,R1,#+1
   \   00000514   1920A0E1           LSL      R2,R9,R0
   \   00000518   920100E0           MUL      R0,R2,R1
   \   0000051C   030000EA           B        ??_Init_34
   2066            } else {
   2067              pInst->NumSectors = SD_CSD_BLOCKNR_HC(pInst);
   \                     ??_Init_33:
   \   00000520   2008A0E1           LSR      R0,R0,#+16
   \   00000524   010880E0           ADD      R0,R0,R1, LSL #+16
   \   00000528   010080E2           ADD      R0,R0,#+1
   \   0000052C   0005A0E1           LSL      R0,R0,#+10
   \                     ??_Init_34:
   \   00000530   140088E5           STR      R0,[R8, #+20]
   2068            }
   2069            FS_DEBUG_LOG((FS_MTYPE_DRIVER, "TAAC %x, NSAC %x\n\r",SD_CSD_TAAC(pInst),SD_CSD_NSAC(pInst)));
   2070            pInst->IsWriteProtected = FS_MCI_HW_IsCardWriteProtected(Unit);
   \   00000534   0400A0E1           MOV      R0,R4
   \   00000538   ........           BL       FS_MCI_HW_IsCardWriteProtected
   \   0000053C   4700C8E5           STRB     R0,[R8, #+71]
   2071            if (pInst->CardType == UNKNOWN_CARD) {
   \   00000540   4600D8E5           LDRB     R0,[R8, #+70]
   \   00000544   000050E3           CMP      R0,#+0
   2072              return SD_ERROR_NOT_INITIALIZED;
   \   00000548   0300A003           MOVEQ    R0,#+3
   \   0000054C   0B00000A           BEQ      ??_Init_4
   2073            } else {
   2074              MCI_SetSpeed(pInst, 20000000);
   \   00000550   184098E5           LDR      R4,[R8, #+24]
   \   00000554   040094E5           LDR      R0,[R4, #+4]
   \   00000558   FF50C0E3           BIC      R5,R0,#0xFF
   \   0000055C   4800D8E5           LDRB     R0,[R8, #+72]
   \   00000560   ........           BL       FS_MCI_HW_GetMClk
   \   00000564   ........           LDR      R2,??DataTable13_4  ;; 0xd6bf94d6
   \   00000568   902281E0           UMULL    R2,R1,R0,R2
   \   0000056C   A10CB0E1           LSRS     R0,R1,#+25
   \   00000570   01004012           SUBNE    R0,R0,#+1
   \   00000574   050080E1           ORR      R0,R0,R5
   \   00000578   040084E5           STR      R0,[R4, #+4]
   2075              FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- Card Type: %x\n\r", pInst->CardType));
   2076              return 0;
   \   0000057C   0000A0E3           MOV      R0,#+0
   \                     ??_Init_4:
   \   00000580   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   00000584   F08FBDE8           POP      {R4-R11,PC}      ;; return
   2077            }
   2078          }
   2079          
   2080          /*********************************************************************
   2081          *
   2082          *       _StopSD
   2083          *
   2084          *  Function description:
   2085          *    Stop the SDcard. This function stops all SD operations.
   2086          *
   2087          *  Parameters:
   2088          *    Unit       - Unit number, which instance shall be used.
   2089          *
   2090          *  Return value:
   2091          *    Returns 0 if successful; otherwise returns an code describing the Error.
   2092          *
   2093          */

   \                                 In section .text, align 4, keep-with-next
   2094          static U8 _StopSD(U8 Unit) {
   \                     _StopSD:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   2095            U8             Error;
   2096            MCI_CMD      * pCommand;
   2097            DRIVER_INST * pInst;
   2098          
   2099            pInst = _apInst[Unit];
   \   00000004   ........           LDR      R1,??DataTable13_1
   \   00000008   004191E7           LDR      R4,[R1, +R0, LSL #+2]
   2100            pCommand = &(pInst->Command);
   2101            if(pCommand->ConTrans == MCI_CONTINUE_TRANSFER) {
   \   0000000C   2800D4E5           LDRB     R0,[R4, #+40]
   \   00000010   010050E3           CMP      R0,#+1
   \   00000014   1E00001A           BNE      ??_StopSD_0
   2102              FS_DEBUG_LOG((FS_MTYPE_DRIVER, "-D- SD_StopTransmission()\n\r"));
   2103              Error = _SendCMD12(pInst);
   \   00000018   1C5084E2           ADD      R5,R4,#+28
   \   0000001C   2410A0E3           MOV      R1,#+36
   \   00000020   0500A0E1           MOV      R0,R5
   \   00000024   ........           BL       __aeabi_memclr4
   \   00000028   4C60A0E3           MOV      R6,#+76
   \   0000002C   846B86E3           ORR      R6,R6,#0x21000
   \   00000030   006085E5           STR      R6,[R5, #+0]
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   0C00C5E5           STRB     R0,[R5, #+12]
   \   0000003C   4500C4E5           STRB     R0,[R4, #+69]
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       __SendCommand
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0100000A           BEQ      ??_StopSD_1
   \   00000050   0100A0E3           MOV      R0,#+1
   \   00000054   7080BDE8           POP      {R4-R6,PC}
   \                     ??_StopSD_1:
   \   00000058   000095E5           LDR      R0,[R5, #+0]
   \   0000005C   060050E1           CMP      R0,R6
   \   00000060   0800001A           BNE      ??_StopSD_2
   \                     ??_StopSD_3:
   \   00000064   180094E5           LDR      R0,[R4, #+24]
   \   00000068   0110A0E3           MOV      R1,#+1
   \   0000006C   001080E5           STR      R1,[R0, #+0]
   \   00000070   401090E5           LDR      R1,[R0, #+64]
   \   00000074   301001E2           AND      R1,R1,#0x30
   \   00000078   200051E3           CMP      R1,#+32
   \   0000007C   F8FFFF1A           BNE      ??_StopSD_3
   \   00000080   0210A0E3           MOV      R1,#+2
   \   00000084   001080E5           STR      R1,[R0, #+0]
   \                     ??_StopSD_2:
   \   00000088   1000D5E5           LDRB     R0,[R5, #+16]
   2104              if(Error) {
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   0900001A           BNE      ??_StopSD_4
   2105                return Error;
   2106              }
   2107            }
   2108            _CloseMCI(pInst);
   \                     ??_StopSD_0:
   \   00000094   185094E5           LDR      R5,[R4, #+24]
   \   00000098   ........           BL       FS_X_OS_Signal
   \   0000009C   0010A0E3           MOV      R1,#+0
   \   000000A0   4800D4E5           LDRB     R0,[R4, #+72]
   \   000000A4   ........           BL       FS_MCI_HW_EnableClock
   \   000000A8   0200A0E3           MOV      R0,#+2
   \   000000AC   000085E5           STR      R0,[R5, #+0]
   \   000000B0   0000E0E3           MVN      R0,#+0
   \   000000B4   480085E5           STR      R0,[R5, #+72]
   2109            return 0;
   \   000000B8   0000A0E3           MOV      R0,#+0
   \                     ??_StopSD_4:
   \   000000BC   7080BDE8           POP      {R4-R6,PC}       ;; return
   2110          }
   2111          
   2112          /*********************************************************************
   2113          *
   2114          *       _GetDeviceInfo
   2115          *
   2116          *  Function description:
   2117          *    Retrieves the SD card information such as Number of sectors available
   2118          *    and sector size.
   2119          *
   2120          *  Parameters:
   2121          *    Unit       - Unit number, which instance shall be used.
   2122          *
   2123          *  Return value:
   2124          *    == 0 - OK
   2125          *    != 0 - Error
   2126          *
   2127          */
   2128          static U8 _GetDeviceInfo(DRIVER_INST * pInst, FS_DEV_INFO * pDevInfo) {
   2129            pDevInfo->NumHeads        = 0;                              // Heads
   2130            pDevInfo->SectorsPerTrack = 0;                              // Sectors per track
   2131            pDevInfo->NumSectors      = SD_TOTAL_BLOCK(pInst);          // Number of sectors
   2132            pDevInfo->BytesPerSector  = SECTOR_SIZE;                    // We use a default sector size of 512 Bytes
   2133            return 0;
   2134          }
   2135          
   2136          /*********************************************************************
   2137          *
   2138          *       _Unmount
   2139          *
   2140          *  Description:
   2141          *    Unmounts the volume.
   2142          *
   2143          *  Parameters:
   2144          *    Unit        - Unit number.
   2145          *
   2146          */
   2147          static void _Unmount(U8 Unit) {
   2148            if (_apInst[Unit]->IsInited == 1) {
   2149              FS_MEMSET(_apInst[Unit], 0, sizeof(DRIVER_INST));
   2150            }
   2151          }
   2152          
   2153          /*********************************************************************
   2154          *
   2155          *       Public code (indirectly thru callback)
   2156          *
   2157          **********************************************************************
   2158          */
   2159          
   2160          /*********************************************************************
   2161          *
   2162          *       _GetStatus
   2163          *
   2164          *  Description:
   2165          *    FS driver function. Get status of the media.
   2166          *
   2167          *  Parameters:
   2168          *    Unit                  - Unit number.
   2169          *
   2170          *  Return value:
   2171          *    FS_MEDIA_STATE_UNKNOWN - if the state of the media is unknown.
   2172          *    FS_MEDIA_NOT_PRESENT   - if no card is present.
   2173          *    FS_MEDIA_IS_PRESENT    - if a card is present.
   2174          */

   \                                 In section .text, align 4, keep-with-next
   2175          static int _GetStatus(U8 Unit) {
   2176            return FS_MCI_HW_IsCardPresent(Unit);
   \                     _GetStatus:
   \   00000000   ........           B        FS_MCI_HW_IsCardPresent  ;; tailcall
   2177          }
   2178          
   2179          /*********************************************************************
   2180          *
   2181          *       _Read
   2182          *
   2183          *  Function Description
   2184          *    Driver callback function.
   2185          *    Reads one or more logical sectors from storage device.
   2186          *
   2187          *  Parameters:
   2188          *    Unit        - Unit number.
   2189          *    Sector      - Sector to be read from the device.
   2190          *    pBuffer     - Pointer to buffer for storing the data.
   2191          *    NumSectors  - Number of sectors to read
   2192          *
   2193          *  Return value:
   2194          *      0                       - Data successfully written.
   2195          *    !=0                       - An error has occurred.
   2196          *
   2197          */

   \                                 In section .text, align 4, keep-with-next
   2198          static int _Read(U8 Unit, U32 SectorNo, void * p, U32 NumSectors) {
   \                     _Read:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   2199            int r;
   2200            U8  Error;
   2201          
   2202            if (_apInst[Unit]->IsInited == 0) {
   \   00000004   ........           LDR      R10,??DataTable13_1
   \   00000008   0090A0E1           MOV      R9,R0
   \   0000000C   09019AE7           LDR      R0,[R10, +R9, LSL #+2]
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   4400D0E5           LDRB     R0,[R0, #+68]
   \   00000018   0160A0E1           MOV      R6,R1
   \   0000001C   0270A0E1           MOV      R7,R2
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0380A0E1           MOV      R8,R3
   2203              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "ReadSector was called before IniMedium was called."));
   2204              return -1;
   \   00000028   0000E003           MVNEQ    R0,#+0
   \   0000002C   4800000A           BEQ      ??_Read_0
   2205            }
   2206            do {
   2207              unsigned NumSectorsAtOnce;
   2208          
   2209              NumSectorsAtOnce = MIN(NumSectors, _apInst[Unit]->NumSectorsAtOnce);
   \                     ??_Read_1:
   \   00000030   09419AE7           LDR      R4,[R10, +R9, LSL #+2]
   \   00000034   08B0A0E1           MOV      R11,R8
   \   00000038   B204D4E1           LDRH     R0,[R4, #+66]
   \   0000003C   000058E1           CMP      R8,R0
   \   00000040   00B0A081           MOVHI    R11,R0
   2210              r = _ReadSectors(Unit, SectorNo, (U8 *)p, NumSectorsAtOnce);
   \   00000044   4500D4E5           LDRB     R0,[R4, #+69]
   \   00000048   010050E3           CMP      R0,#+1
   \   0000004C   0300001A           BNE      ??_Read_2
   \   00000050   100094E5           LDR      R0,[R4, #+16]
   \   00000054   010080E2           ADD      R0,R0,#+1
   \   00000058   060050E1           CMP      R0,R6
   \   0000005C   0700000A           BEQ      ??_Read_3
   \                     ??_Read_2:
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   00008DE5           STR      R0,[SP, #+0]
   \   00000068   0730A0E1           MOV      R3,R7
   \   0000006C   0B20A0E1           MOV      R2,R11
   \   00000070   0610A0E1           MOV      R1,R6
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       _MoveToTransferState
   \   0000007C   0A0000EA           B        ??_Read_4
   \                     ??_Read_3:
   \   00000080   4600D4E5           LDRB     R0,[R4, #+70]
   \   00000084   0720A0E1           MOV      R2,R7
   \   00000088   0B10A0E1           MOV      R1,R11
   \   0000008C   020050E3           CMP      R0,#+2
   \   00000090   8634A011           LSLNE    R3,R6,#+9
   \   00000094   0630A001           MOVEQ    R3,R6
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       _ContinuousRead
   \   000000A0   0B1086E0           ADD      R1,R6,R11
   \   000000A4   011041E2           SUB      R1,R1,#+1
   \   000000A8   101084E5           STR      R1,[R4, #+16]
   2211              p           = (void *)((U8 *)p + NumSectorsAtOnce * 512);
   2212              NumSectors -= NumSectorsAtOnce;
   \                     ??_Read_4:
   \   000000AC   0B8048E0           SUB      R8,R8,R11
   \   000000B0   0040A0E1           MOV      R4,R0
   \   000000B4   8B7487E0           ADD      R7,R7,R11, LSL #+9
   2213              SectorNo   += NumSectorsAtOnce;
   \   000000B8   06608BE0           ADD      R6,R11,R6
   2214            } while (NumSectors);
   \   000000BC   000058E3           CMP      R8,#+0
   \   000000C0   DAFFFF1A           BNE      ??_Read_1
   2215            if((_apInst[Unit]->State == SD_STATE_DATA) || (_apInst[Unit]->State == SD_STATE_RCV)) {
   \   000000C4   09519AE7           LDR      R5,[R10, +R9, LSL #+2]
   \   000000C8   4500D5E5           LDRB     R0,[R5, #+69]
   \   000000CC   010050E3           CMP      R0,#+1
   \   000000D0   02005013           CMPNE    R0,#+2
   \   000000D4   1D00001A           BNE      ??_Read_5
   2216              Error = _SendCMD12(_apInst[Unit]);
   \   000000D8   1C6085E2           ADD      R6,R5,#+28
   \   000000DC   2410A0E3           MOV      R1,#+36
   \   000000E0   0600A0E1           MOV      R0,R6
   \   000000E4   ........           BL       __aeabi_memclr4
   \   000000E8   4C70A0E3           MOV      R7,#+76
   \   000000EC   847B87E3           ORR      R7,R7,#0x21000
   \   000000F0   007086E5           STR      R7,[R6, #+0]
   \   000000F4   0000A0E3           MOV      R0,#+0
   \   000000F8   0C00C6E5           STRB     R0,[R6, #+12]
   \   000000FC   4500C5E5           STRB     R0,[R5, #+69]
   \   00000100   0500A0E1           MOV      R0,R5
   \   00000104   ........           BL       __SendCommand
   \   00000108   000050E3           CMP      R0,#+0
   \   0000010C   0100A013           MOVNE    R0,#+1
   \   00000110   0F00001A           BNE      ??_Read_0
   \   00000114   000096E5           LDR      R0,[R6, #+0]
   \   00000118   070050E1           CMP      R0,R7
   \   0000011C   0800001A           BNE      ??_Read_6
   \                     ??_Read_7:
   \   00000120   180095E5           LDR      R0,[R5, #+24]
   \   00000124   0110A0E3           MOV      R1,#+1
   \   00000128   001080E5           STR      R1,[R0, #+0]
   \   0000012C   401090E5           LDR      R1,[R0, #+64]
   \   00000130   301001E2           AND      R1,R1,#0x30
   \   00000134   200051E3           CMP      R1,#+32
   \   00000138   F8FFFF1A           BNE      ??_Read_7
   \   0000013C   0210A0E3           MOV      R1,#+2
   \   00000140   001080E5           STR      R1,[R0, #+0]
   \                     ??_Read_6:
   \   00000144   1000D6E5           LDRB     R0,[R6, #+16]
   2217              if (Error) {
   \   00000148   000050E3           CMP      R0,#+0
   \   0000014C   0000001A           BNE      ??_Read_0
   2218                return Error;
   2219              }
   2220            }
   2221            return r;
   \                     ??_Read_5:
   \   00000150   0400A0E1           MOV      R0,R4
   \                     ??_Read_0:
   \   00000154   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000158   F08FBDE8           POP      {R4-R11,PC}      ;; return
   2222          }
   2223          
   2224          /*********************************************************************
   2225          *
   2226          *       _Write
   2227          *
   2228          *  Description:
   2229          *    Driver callback function.
   2230          *    Writes one or more logical sectors to storage device.
   2231          *
   2232          *  Parameters:
   2233          *    Unit        - Unit number.
   2234          *    SectorNo    - Sector number to be written to the device.
   2235          *    pBuffer     - Pointer to buffer containing the data to write
   2236          *    NumSectors  - Number of sectors to store.
   2237          *    RepeatSame  - Repeat the same data to sectors.
   2238          *
   2239          *  Return value:
   2240          *      0                       - Data successfully written.
   2241          *    !=0                       - An error has occurred.
   2242          *
   2243          */

   \                                 In section .text, align 4, keep-with-next
   2244          static int _Write(U8 Unit, U32 SectorNo, const void  * p, U32 NumSectors, U8  RepeatSame) {
   \                     _Write:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   2245            int r;
   2246            U8 Error;
   2247          
   2248            if (_apInst[Unit]->IsInited == 0) {
   \   00000004   ........           LDR      R6,??DataTable13_1
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0180A0E1           MOV      R8,R1
   \   00000010   051196E7           LDR      R1,[R6, +R5, LSL #+2]
   \   00000014   04D04DE2           SUB      SP,SP,#+4
   \   00000018   4410D1E5           LDRB     R1,[R1, #+68]
   \   0000001C   2800DDE5           LDRB     R0,[SP, #+40]
   \   00000020   0270A0E1           MOV      R7,R2
   \   00000024   000051E3           CMP      R1,#+0
   \   00000028   0390A0E1           MOV      R9,R3
   2249              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "WriteSector was called before IniMedium was called."));
   2250              return -1;
   \   0000002C   0000E003           MVNEQ    R0,#+0
   \   00000030   7300000A           BEQ      ??_Write_0
   2251            }
   2252            r = 0;
   \   00000034   0040A0E3           MOV      R4,#+0
   2253            if (RepeatSame) {
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   2200000A           BEQ      ??_Write_1
   2254              do {
   2255                if (_WriteSectors(Unit, SectorNo, (const U8 *)p, 1)) {
   \                     ??_Write_2:
   \   00000040   05A196E7           LDR      R10,[R6, +R5, LSL #+2]
   \   00000044   4700DAE5           LDRB     R0,[R10, #+71]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   1800001A           BNE      ??_Write_3
   \   00000050   4500DAE5           LDRB     R0,[R10, #+69]
   \   00000054   020050E3           CMP      R0,#+2
   \   00000058   0300001A           BNE      ??_Write_4
   \   0000005C   10009AE5           LDR      R0,[R10, #+16]
   \   00000060   010080E2           ADD      R0,R0,#+1
   \   00000064   080050E1           CMP      R0,R8
   \   00000068   0600000A           BEQ      ??_Write_5
   \                     ??_Write_4:
   \   0000006C   00408DE5           STR      R4,[SP, #+0]
   \   00000070   0730A0E1           MOV      R3,R7
   \   00000074   0120A0E3           MOV      R2,#+1
   \   00000078   0810A0E1           MOV      R1,R8
   \   0000007C   0A00A0E1           MOV      R0,R10
   \   00000080   ........           BL       _MoveToTransferState
   \   00000084   080000EA           B        ??_Write_6
   \                     ??_Write_5:
   \   00000088   4600DAE5           LDRB     R0,[R10, #+70]
   \   0000008C   0720A0E1           MOV      R2,R7
   \   00000090   0110A0E3           MOV      R1,#+1
   \   00000094   020050E3           CMP      R0,#+2
   \   00000098   8834A011           LSLNE    R3,R8,#+9
   \   0000009C   0830A001           MOVEQ    R3,R8
   \   000000A0   0A00A0E1           MOV      R0,R10
   \   000000A4   ........           BL       _ContinuousWrite
   \   000000A8   10808AE5           STR      R8,[R10, #+16]
   \                     ??_Write_6:
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   0100000A           BEQ      ??_Write_7
   2256                  r = -1;
   \                     ??_Write_3:
   \   000000B4   0040E0E3           MVN      R4,#+0
   2257                  break;
   \   000000B8   2D0000EA           B        ??_Write_8
   2258                }
   2259                SectorNo++;
   \                     ??_Write_7:
   \   000000BC   018088E2           ADD      R8,R8,#+1
   2260              } while (--NumSectors);
   \   000000C0   019059E2           SUBS     R9,R9,#+1
   \   000000C4   DDFFFF1A           BNE      ??_Write_2
   \   000000C8   290000EA           B        ??_Write_8
   2261            } else {
   2262              do {
   2263                unsigned NumSectorsAtOnce;
   2264                NumSectorsAtOnce = MIN(NumSectors, _apInst[Unit]->NumSectorsAtOnce);
   \                     ??_Write_1:
   \   000000CC   054196E7           LDR      R4,[R6, +R5, LSL #+2]
   \   000000D0   09B0A0E1           MOV      R11,R9
   \   000000D4   B204D4E1           LDRH     R0,[R4, #+66]
   \   000000D8   000059E1           CMP      R9,R0
   \   000000DC   00B0A081           MOVHI    R11,R0
   2265                r = _WriteSectors(Unit, SectorNo, (const U8*)p, NumSectorsAtOnce);
   \   000000E0   4700D4E5           LDRB     R0,[R4, #+71]
   \   000000E4   000050E3           CMP      R0,#+0
   \   000000E8   0100A013           MOVNE    R0,#+1
   \   000000EC   1900001A           BNE      ??_Write_9
   \   000000F0   4500D4E5           LDRB     R0,[R4, #+69]
   \   000000F4   020050E3           CMP      R0,#+2
   \   000000F8   0300001A           BNE      ??_Write_10
   \   000000FC   100094E5           LDR      R0,[R4, #+16]
   \   00000100   010080E2           ADD      R0,R0,#+1
   \   00000104   080050E1           CMP      R0,R8
   \   00000108   0700000A           BEQ      ??_Write_11
   \                     ??_Write_10:
   \   0000010C   0000A0E3           MOV      R0,#+0
   \   00000110   00008DE5           STR      R0,[SP, #+0]
   \   00000114   0730A0E1           MOV      R3,R7
   \   00000118   0B20A0E1           MOV      R2,R11
   \   0000011C   0810A0E1           MOV      R1,R8
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       _MoveToTransferState
   \   00000128   0A0000EA           B        ??_Write_9
   \                     ??_Write_11:
   \   0000012C   4600D4E5           LDRB     R0,[R4, #+70]
   \   00000130   0720A0E1           MOV      R2,R7
   \   00000134   0B10A0E1           MOV      R1,R11
   \   00000138   020050E3           CMP      R0,#+2
   \   0000013C   8834A011           LSLNE    R3,R8,#+9
   \   00000140   0830A001           MOVEQ    R3,R8
   \   00000144   0400A0E1           MOV      R0,R4
   \   00000148   ........           BL       _ContinuousWrite
   \   0000014C   0B1088E0           ADD      R1,R8,R11
   \   00000150   011041E2           SUB      R1,R1,#+1
   \   00000154   101084E5           STR      R1,[R4, #+16]
   \                     ??_Write_9:
   \   00000158   0040B0E1           MOVS     R4,R0
   2266                if (r) {
   \   0000015C   D4FFFF1A           BNE      ??_Write_3
   2267                  r = -1;
   2268                  break;
   2269                }
   2270                p           = (const void *)((const U8 *)p + NumSectorsAtOnce * 512);
   2271                NumSectors -= NumSectorsAtOnce;
   \   00000160   0B9049E0           SUB      R9,R9,R11
   \   00000164   8B7487E0           ADD      R7,R7,R11, LSL #+9
   2272                SectorNo   += NumSectorsAtOnce;
   \   00000168   08808BE0           ADD      R8,R11,R8
   2273              } while (NumSectors);
   \   0000016C   000059E3           CMP      R9,#+0
   \   00000170   D5FFFF1A           BNE      ??_Write_1
   2274            }
   2275            if((_apInst[Unit]->State == SD_STATE_DATA) || (_apInst[Unit]->State == SD_STATE_RCV)) {
   \                     ??_Write_8:
   \   00000174   055196E7           LDR      R5,[R6, +R5, LSL #+2]
   \   00000178   4500D5E5           LDRB     R0,[R5, #+69]
   \   0000017C   010050E3           CMP      R0,#+1
   \   00000180   02005013           CMPNE    R0,#+2
   \   00000184   1D00001A           BNE      ??_Write_12
   2276              Error = _SendCMD12(_apInst[Unit]);
   \   00000188   1C6085E2           ADD      R6,R5,#+28
   \   0000018C   2410A0E3           MOV      R1,#+36
   \   00000190   0600A0E1           MOV      R0,R6
   \   00000194   ........           BL       __aeabi_memclr4
   \   00000198   4C70A0E3           MOV      R7,#+76
   \   0000019C   847B87E3           ORR      R7,R7,#0x21000
   \   000001A0   007086E5           STR      R7,[R6, #+0]
   \   000001A4   0000A0E3           MOV      R0,#+0
   \   000001A8   0C00C6E5           STRB     R0,[R6, #+12]
   \   000001AC   4500C5E5           STRB     R0,[R5, #+69]
   \   000001B0   0500A0E1           MOV      R0,R5
   \   000001B4   ........           BL       __SendCommand
   \   000001B8   000050E3           CMP      R0,#+0
   \   000001BC   0100A013           MOVNE    R0,#+1
   \   000001C0   0F00001A           BNE      ??_Write_0
   \   000001C4   000096E5           LDR      R0,[R6, #+0]
   \   000001C8   070050E1           CMP      R0,R7
   \   000001CC   0800001A           BNE      ??_Write_13
   \                     ??_Write_14:
   \   000001D0   180095E5           LDR      R0,[R5, #+24]
   \   000001D4   0110A0E3           MOV      R1,#+1
   \   000001D8   001080E5           STR      R1,[R0, #+0]
   \   000001DC   401090E5           LDR      R1,[R0, #+64]
   \   000001E0   301001E2           AND      R1,R1,#0x30
   \   000001E4   200051E3           CMP      R1,#+32
   \   000001E8   F8FFFF1A           BNE      ??_Write_14
   \   000001EC   0210A0E3           MOV      R1,#+2
   \   000001F0   001080E5           STR      R1,[R0, #+0]
   \                     ??_Write_13:
   \   000001F4   1000D6E5           LDRB     R0,[R6, #+16]
   2277              if (Error) {
   \   000001F8   000050E3           CMP      R0,#+0
   \   000001FC   0000001A           BNE      ??_Write_0
   2278                return Error;
   2279              }
   2280            }
   2281            return r;
   \                     ??_Write_12:
   \   00000200   0400A0E1           MOV      R0,R4
   \                     ??_Write_0:
   \   00000204   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000208   F08FBDE8           POP      {R4-R11,PC}      ;; return
   2282          }
   2283          
   2284          /*********************************************************************
   2285          *
   2286          *       _DevIoCtl
   2287          *
   2288          *  Description:
   2289          *    FS driver function. Execute device command.
   2290          *
   2291          *  Parameters:
   2292          *    Unit    - Unit number.
   2293          *    Cmd         - Command to be executed.
   2294          *    Aux         - Parameter depending on command.
   2295          *    pBuffer     - Pointer to a buffer used for the command.
   2296          *
   2297          *  Return value:
   2298          *    Command specific. In general a negative value means an error.
   2299          */

   \                                 In section .text, align 4, keep-with-next
   2300          static int _IoCtl(U8 Unit, I32 Cmd, I32 Aux, void *pBuffer) {
   \                     _IoCtl:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   ........           LDR      R12,??DataTable13_1
   \   00000008   0020A0E1           MOV      R2,R0
   \   0000000C   02219CE7           LDR      R2,[R12, +R2, LSL #+2]
   \   00000010   44C0D2E5           LDRB     R12,[R2, #+68]
   \   00000014   00005CE3           CMP      R12,#+0
   \   00000018   0100001A           BNE      ??_IoCtl_0
   2301            FS_DEV_INFO * pInfo;
   2302            int           r;
   2303          
   2304            if (_apInst[Unit]->IsInited == 0) {
   2305              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "IoCtl was called before IniMedium was called."));
   2306              return -1;
   \   0000001C   0000E0E3           MVN      R0,#+0
   \   00000020   1080BDE8           POP      {R4,PC}
   2307            }
   2308            r     = -1;
   \                     ??_IoCtl_0:
   \   00000024   0040E0E3           MVN      R4,#+0
   2309            FS_USE_PARA(Aux);
   2310            switch (Cmd) {
   \   00000028   FB1F51E2           SUBS     R1,R1,#+1004
   \   0000002C   0400000A           BEQ      ??_IoCtl_1
   \   00000030   041051E2           SUBS     R1,R1,#+4
   \   00000034   0B00000A           BEQ      ??_IoCtl_2
   \   00000038   011051E2           SUBS     R1,R1,#+1
   \   0000003C   ........           BLEQ     _StopSD
   \   00000040   0E0000EA           B        ??_IoCtl_3
   2311            case FS_CMD_GET_DEVINFO:
   2312              pInfo = (FS_DEV_INFO *)pBuffer;
   2313              r = _GetDeviceInfo(_apInst[Unit], pInfo);
   \                     ??_IoCtl_1:
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   B000C3E1           STRH     R0,[R3, #+0]
   \   0000004C   B200C3E1           STRH     R0,[R3, #+2]
   \   00000050   140092E5           LDR      R0,[R2, #+20]
   \   00000054   040083E5           STR      R0,[R3, #+4]
   \   00000058   800FA0E3           MOV      R0,#+512
   \   0000005C   B800C3E1           STRH     R0,[R3, #+8]
   \                     ??_IoCtl_4:
   \   00000060   0040A0E3           MOV      R4,#+0
   2314              break;
   \   00000064   050000EA           B        ??_IoCtl_3
   2315            case FS_CMD_UNMOUNT:
   2316              //
   2317              // (Optional)
   2318              // Device shall be unmounted - sync all operations and mark it as unmounted
   2319              //
   2320              _Unmount(Unit);
   \                     ??_IoCtl_2:
   \   00000068   01005CE3           CMP      R12,#+1
   \   0000006C   FBFFFF1A           BNE      ??_IoCtl_4
   \   00000070   4C10A0E3           MOV      R1,#+76
   \   00000074   0200A0E1           MOV      R0,R2
   \   00000078   ........           BL       __aeabi_memclr4
   2321              r = 0;
   \   0000007C   F7FFFFEA           B        ??_IoCtl_4
   2322              break;
   2323            case FS_CMD_UNMOUNT_FORCED:
   2324              //
   2325              // (Optional)
   2326              // Device shall be unmounted - mark it as unmounted without syncing any pending operations
   2327              //
   2328              _StopSD(Unit);
   2329              break;
   2330            case FS_CMD_SYNC:
   2331              //
   2332              // (Optional)
   2333              // Sync/flush any pending operations
   2334              //
   2335          
   2336              // ToDo: Call the function
   2337              break;
   2338            default:
   2339              break;
   2340            }
   2341            return r;
   \                     ??_IoCtl_3:
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   1080BDE8           POP      {R4,PC}          ;; return
   2342          }
   2343          
   2344          /*********************************************************************
   2345          *
   2346          *       _InitMedium
   2347          *
   2348          *  Description:
   2349          *    Initialize the specified medium.
   2350          *
   2351          *  Parameters:
   2352          *    Unit    - Unit number.
   2353          *
   2354          *  Return value:
   2355          */

   \                                 In section .text, align 4, keep-with-next
   2356          static int _InitMedium(U8 Unit) {
   \                     _InitMedium:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   2357            int i;
   2358            DRIVER_INST * pInst;
   2359          
   2360            pInst = _apInst[Unit];
   \   00000004   ........           LDR      R5,??DataTable13_1
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   006195E7           LDR      R6,[R5, +R0, LSL #+2]
   2361            if (pInst->IsInited == 0) {
   \   00000010   4400D6E5           LDRB     R0,[R6, #+68]
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   1100001A           BNE      ??_InitMedium_0
   2362              //
   2363              // Initialize transfer memory variables
   2364              // which are used by the DMA to read/write data
   2365              //
   2366              _TransferMemSize = FS_MCI_HW_GetTransferMem(&_PAddrTransferMem, &_VAddrTransferMem);
   \   0000001C   141085E2           ADD      R1,R5,#+20
   \   00000020   100085E2           ADD      R0,R5,#+16
   \   00000024   ........           BL       FS_MCI_HW_GetTransferMem
   2367              if (_TransferMemSize < (1 << SECTOR_SIZE_SHIFT)) {
   \   00000028   800F50E3           CMP      R0,#+512
   \   0000002C   0100002A           BCS      ??_InitMedium_1
   2368                FS_DEBUG_WARN((FS_MTYPE_DRIVER, "Size of transfer memory area for DMA is too small. A minimum of 512 bytes is needed."));
   2369                return -1;
   \                     ??_InitMedium_2:
   \   00000030   0000E0E3           MVN      R0,#+0
   \   00000034   7080BDE8           POP      {R4-R6,PC}
   2370              }
   2371              _NumSectorsAtOnce = _TransferMemSize >> SECTOR_SIZE_SHIFT;
   \                     ??_InitMedium_1:
   \   00000038   A004B0E1           LSRS     R0,R0,#+9
   \   0000003C   0C0085E5           STR      R0,[R5, #+12]
   2372              if (_NumSectorsAtOnce < 1) {
   \   00000040   FAFFFF0A           BEQ      ??_InitMedium_2
   2373                FS_DEBUG_WARN((FS_MTYPE_DRIVER, "Size of transfer memory area for DMA is too small. A minimum of 512 bytes is needed."));
   2374                return -1;
   2375              }
   2376              i = _Init(Unit);
   2377              if (i) { /* init failed, no valid card in slot */
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       _Init
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   F6FFFF1A           BNE      ??_InitMedium_2
   2378                FS_DEBUG_WARN((FS_MTYPE_DRIVER, "IDE/CF: Init failure, no valid card found"));
   2379                return -1;
   2380              } else {
   2381                pInst->NumSectorsAtOnce = _NumSectorsAtOnce;
   \   00000054   0C0095E5           LDR      R0,[R5, #+12]
   \   00000058   B204C6E1           STRH     R0,[R6, #+66]
   2382                pInst->IsInited = 1;
   \   0000005C   0100A0E3           MOV      R0,#+1
   \   00000060   4400C6E5           STRB     R0,[R6, #+68]
   2383              }
   2384            }
   2385            return 0;
   \                     ??_InitMedium_0:
   \   00000064   0000A0E3           MOV      R0,#+0
   \   00000068   7080BDE8           POP      {R4-R6,PC}       ;; return
   2386          }
   2387          
   2388          /*********************************************************************
   2389          *
   2390          *       _AddDevice
   2391          *
   2392          *  Function Description:
   2393          *    Initializes the low-level driver object.
   2394          *
   2395          *  Return value:
   2396          *    >= 0                       - Command successfully executed, Unit no.
   2397          *    <  0                       - Error, could not add device
   2398          *
   2399          */

   \                                 In section .text, align 4, keep-with-next
   2400          static int _AddDevice(void) {
   \                     _AddDevice:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   2401            U8            Unit;
   2402            DRIVER_INST * pInst;
   2403          
   2404            if (_NumUnits >= NUM_UNITS) {
   \   00000004   ........           LDR      R4,??DataTable13_1
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   080094E5           LDR      R0,[R4, #+8]
   \   00000010   020050E3           CMP      R0,#+2
   2405              return -1;
   \   00000014   0000E0A3           MVNGE    R0,#+0
   \   00000018   060000AA           BGE      ??_AddDevice_0
   2406            }
   2407            Unit = _NumUnits++;
   \   0000001C   FF5000E2           AND      R5,R0,#0xFF
   \   00000020   010080E2           ADD      R0,R0,#+1
   \   00000024   080084E5           STR      R0,[R4, #+8]
   2408            pInst = (DRIVER_INST *)FS_AllocZeroed(sizeof(DRIVER_INST));   // Alloc memory. This is guaranteed to work by the memory module.
   2409            _apInst[Unit] = pInst;
   \   00000028   4C00A0E3           MOV      R0,#+76
   \   0000002C   ........           BL       FS_AllocZeroed
   \   00000030   050184E7           STR      R0,[R4, +R5, LSL #+2]
   2410            return Unit;
   \   00000034   0500A0E1           MOV      R0,R5
   \                     ??_AddDevice_0:
   \   00000038   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000003C   3080BDE8           POP      {R4,R5,PC}       ;; return
   2411          }
   2412          
   2413          /*********************************************************************
   2414          *
   2415          *       _GetNumUnits
   2416          *
   2417          *  Function description:
   2418          *
   2419          *  Return value:
   2420          *    >= 0                       - Command successfully executed, Unit no.
   2421          *    <  0                       - Error, could not add device
   2422          */

   \                                 In section .text, align 4, keep-with-next
   2423          static int _GetNumUnits(void) {
   2424            return _NumUnits;
   \                     _GetNumUnits:
   \   00000000   ........           LDR      R0,??DataTable13_1
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   1EFF2FE1           BX       LR               ;; return
   2425          }
   2426          
   2427          /*********************************************************************
   2428          *
   2429          *       _GetDriverName
   2430          */

   \                                 In section .text, align 4, keep-with-next
   2431          static const char * _GetDriverName(U8 Unit) {
   2432            FS_USE_PARA(Unit);
   2433            return "mmc";
   \                     _GetDriverName:
   \   00000000   ........           ADR      R0,??DataTable13  ;; "mmc"
   \   00000004   1EFF2FE1           BX       LR               ;; return
   2434          }
   2435          
   2436          /*********************************************************************
   2437          *
   2438          *       Public data
   2439          *
   2440          **********************************************************************
   2441          */

   \                                 In section .rodata, align 4, keep-with-next
   2442          const FS_DEVICE_TYPE FS_MMC_CM_Driver4Atmel = {
   \                     FS_MMC_CM_Driver4Atmel:
   \   00000000                      ; Initializer data, 32 bytes
   \   00000000   ............       DC32 _GetDriverName, _AddDevice, _Read, _Write, _IoCtl, _InitMedium, _GetStatus, _GetNumUnits
   \              ............
   \              ............
   \              ............
   \              ............
   \              ....        

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     _apInst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     _OnSectorsRead

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   40007FC0           DC32     0xc07f0040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   6D6D6300           DC8      "mmc"

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   ........           DC32     _apInst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   47ACC5A7           DC32     0xa7c5ac47

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   ........           DC32     _ISRHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   D694BFD6           DC32     0xd6bf94d6

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "mmc">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   6D6D6300           DC8 109, 109, 99, 0
   2443            _GetDriverName,
   2444            _AddDevice,
   2445            _Read,
   2446            _Write,
   2447            _IoCtl,
   2448            _InitMedium,
   2449            _GetStatus,
   2450            _GetNumUnits
   2451          };
   2452          
   2453          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function             .cstack
     --------             -------
     _AddDevice               16
     _ContinuousRead          24
     _ContinuousWrite         24
     _GetDriverName            0
     _GetNumUnits              0
     _GetStatus                8
     _ISRHandler               8
     _Init                    72
     _InitMedium              16
     _IoCtl                    8
     _MoveToTransferState     40
     _OnSectorsRead            8
     _Read                    40
     _SendACMD41              56
     _SendACMD6               32
     _SendCMD1                24
     _SendCMD13               24
     _SendCMD18               24
     _SendCMD25               24
     _SendCMD3                24
     _SendCMD8                24
     _SendCMD9                16
     _StopSD                  16
     _Write                   40
     __SendCommand            32


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     _apInst                  24
     _NumUnits
     _NumSectorsAtOnce
     _PAddrTransferMem
     _VAddrTransferMem
     _TransferMemSize          4
     _OnSectorsRead           32
     _ISRHandler             268
     __SendCommand           408
     _SendCMD1               180
     _SendCMD3               192
     _SendCMD8               192
     _SendCMD9               160
     _SendCMD13              160
     _SendCMD18              168
     _SendCMD25              168
     _SendACMD6              284
     _SendACMD41             344
     _ContinuousRead         156
     _ContinuousWrite        148
     _MoveToTransferState    536
     _Init                  1416
     _StopSD                 192
     _GetStatus                4
     _Read                   348
     _Write                  524
     _IoCtl                  136
     _InitMedium             108
     _AddDevice               64
     _GetNumUnits             12
     _GetDriverName            8
     FS_MMC_CM_Driver4Atmel   32
     ??DataTable4              4
     ??DataTable4_1            4
     ??DataTable4_2            4
     ??DataTable13             4
     ??DataTable13_1           4
     ??DataTable13_2           4
     ??DataTable13_3           4
     ??DataTable13_4           4
     ?<Constant "mmc">         4

 
    28 bytes in section .bss
    36 bytes in section .rodata
 6 240 bytes in section .text
 
 6 240 bytes of CODE  memory
    36 bytes of CONST memory
    28 bytes of DATA  memory

Errors: none
Warnings: 1
